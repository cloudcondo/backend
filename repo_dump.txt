PROJECT EXPORT (plain text)
Root: /workspaces/backend
Generated: 2025-09-18 15:44:03 UTC
Files included: 51
Max bytes per file: 200000
include_sensitive: False
include_binaries: False
autocommit: False
git_include_ignored: False
WARNING: If include_sensitive=True, secrets like .env are included in this export.
================================================================================

================================================================================
FILE: .devcontainer/devcontainer.json
================================================================================
{
  "name": "Condo SaaS Dev",
  "image": "mcr.microsoft.com/devcontainers/python:3.12",
  "postCreateCommand": "sudo apt-get update && sudo apt-get install -y postgresql-client && pip install --upgrade pip && pip install django djangorestframework psycopg2-binary gunicorn",
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-python.python",
        "esbenp.prettier-vscode"
      ]
    }
  }
}

================================================================================
FILE: .dockerignore
================================================================================
__pycache__/
*.pyc
*.pyo
*.pyd
*.sqlite3
.env
.git
.gitignore
.github/
.vscode/
**/__pycache__/
.media/
staticfiles/

================================================================================
FILE: .env.ci
================================================================================
DEBUG=True
SECRET_KEY=dev-secret-only
ALLOWED_HOSTS=*
CSRF_TRUSTED_ORIGINS=https://bug-free-sniffle-g4wjp5v9g45j2v7pw-8000.app.github.dev,https://localhost:8000,http://localhost:8000

================================================================================
FILE: .env.example
================================================================================
# Copy to .env and fill in for local/dev/prod as needed
DEBUG=True
SECRET_KEY=fill-me
ALLOWED_HOSTS=*
CSRF_TRUSTED_ORIGINS=https://your-app.example.com,https://admin.your-app.example.com

# When moving to Postgres:
# DB_ENGINE=postgres
# DB_NAME=app
# DB_USER=app
# DB_PASSWORD=supersecret
# DB_HOST=your-rds-endpoint
# DB_PORT=5432

================================================================================
FILE: .github/workflows/ci.yml
================================================================================
name: CI (build, test, push image)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    name: Django tests (SQLite)
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version: [ "3.12", "3.13" ]  # keep 3.12; add 3.13 to match local
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            pip-${{ runner.os }}-${{ matrix.python-version }}-

      - name: Install system packages (none required)
        run: sudo apt-get update

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Django checks, migrate, seed, test
        env:
          DJANGO_SETTINGS_MODULE: condo_backend.settings
          SECRET_KEY: ci-only-secret-key-change-me
          DEBUG: "True"
          ALLOWED_HOSTS: "*"
        run: |
          python manage.py check
          python manage.py migrate --noinput
          # seed sample data for predictable tests
          python manage.py load_sample_data || true
          python manage.py test --verbosity 2

  build-and-push:
    name: Build and push Docker image to GHCR
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha
            type=ref,event=branch

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

================================================================================
FILE: .gitignore
================================================================================
# Python
__pycache__/
*.pyc
*.pyo
*.pyd
*.sqlite3
db.sqlite3

# Envs
.venv/
env/
venv/

# Django
staticfiles/
media/

# VS Code / Codespaces
.vscode/
.python-version

# Byte-compiled
*.egg-info/
dist/
build/

# dotenv
.env

================================================================================
FILE: Dockerfile
================================================================================
# Python base
FROM python:3.12-slim

# Prevent Python from buffering stdout/stderr
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1

# OS packages (add build deps only if needed later)
RUN apt-get update && apt-get install -y --no-install-recommends \
    libpq5 curl && \
    rm -rf /var/lib/apt/lists/*

# Workdir
WORKDIR /app

# Install Python deps first (better Docker layer caching)
COPY requirements.txt /app/
RUN pip install --upgrade pip && pip install -r requirements.txt

# Copy project
COPY . /app/

# Runtime env (safe defaults; we’ll override in ECS later)
ENV DJANGO_SETTINGS_MODULE=condo_backend.settings \
    PORT=8000

# Expose port for container platforms
EXPOSE 8000

# Start Gunicorn (Django’s WSGI server)
CMD ["gunicorn", "condo_backend.wsgi:application", "--bind", "0.0.0.0:8000", "--workers", "3", "--timeout", "120"]

================================================================================
FILE: README.md
================================================================================
# backend

================================================================================
FILE: accounts/__init__.py
================================================================================
default_app_config = "accounts.apps.AccountsConfig"

================================================================================
FILE: accounts/admin.py
================================================================================
from django.contrib import admin
from django.utils.html import format_html
from .models import UserProfile, UnitAccess

@admin.register(UserProfile)
class UserProfileAdmin(admin.ModelAdmin):
    list_display = ("user", "role", "condo", "created_at", "updated_at")
    list_filter = ("role", "condo")
    search_fields = ("user__username", "user__email", "phone")

@admin.register(UnitAccess)
class UnitAccessAdmin(admin.ModelAdmin):
    list_display = ("user", "unit", "access_type", "active", "created_at", "updated_at")
    list_filter = ("access_type", "active", "unit__condo")
    search_fields = ("user__username", "user__email", "unit__unit_number")

================================================================================
FILE: accounts/apps.py
================================================================================
from django.apps import AppConfig

class AccountsConfig(AppConfig):
    default_auto_field = "django.db.models.AutoField"
    name = "accounts"
    verbose_name = "Accounts"

    def ready(self):
        # import signals so post_save hooks register
        from . import signals  # noqa: F401

================================================================================
FILE: accounts/migrations/0001_initial.py
================================================================================
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion

class Migration(migrations.Migration):

    initial = True

    # Make sure core tables exist first (Unit/Condo)
    dependencies = [
        ("core", "0006_remove_parkingspot_notes_db"),  # safe, already applied in your project
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="UserProfile",
            fields=[
                ("id", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("role", models.CharField(choices=[("pm","Property Manager"),("concierge","Concierge"),("owner","Owner"),("guest","Guest"),("partner","Rental Manager / Partner")], default="guest", max_length=20)),
                ("phone", models.CharField(blank=True, default="", max_length=50)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("condo", models.ForeignKey(blank=True, help_text="Primary condo this user is associated with (optional).", null=True, on_delete=django.db.models.deletion.SET_NULL, to="core.condo")),
                ("user", models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name="profile", to=settings.AUTH_USER_MODEL)),
            ],
            options={
                "verbose_name": "User Profile",
                "verbose_name_plural": "User Profiles",
                "db_table": "accounts_userprofile",
            },
        ),
        migrations.CreateModel(
            name="UnitAccess",
            fields=[
                ("id", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("access_type", models.CharField(choices=[("owner","Owner"),("rental_manager","Rental Manager"),("tenant","Tenant"),("guest_submitter","Guest Submitter")], default="owner", max_length=20)),
                ("active", models.BooleanField(default=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("unit", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name="accesses", to="core.unit")),
                ("user", models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name="unit_accesses", to=settings.AUTH_USER_MODEL)),
            ],
            options={
                "verbose_name": "Unit Access",
                "verbose_name_plural": "Unit Access",
                "db_table": "accounts_unitaccess",
                "unique_together": {("user", "unit", "access_type")},
            },
        ),
    ]

================================================================================
FILE: accounts/models.py
================================================================================
from django.conf import settings
from django.db import models

User = settings.AUTH_USER_MODEL


class Role:
    """Lightweight enum-like constants used in views/permissions."""
    PROPERTY_MANAGER = "pm"
    CONCIERGE = "concierge"
    OWNER = "owner"
    GUEST = "guest"
    PARTNER = "partner"  # Rental manager / 3rd-party agent

    CHOICES = [
        (PROPERTY_MANAGER, "Property Manager"),
        (CONCIERGE, "Concierge"),
        (OWNER, "Owner"),
        (GUEST, "Guest"),
        (PARTNER, "Rental Manager / Partner"),
    ]


class AccessType:
    OWNER = "owner"
    RENTAL_MANAGER = "rental_manager"
    TENANT = "tenant"
    GUEST_SUBMITTER = "guest_submitter"

    CHOICES = [
        (OWNER, "Owner"),
        (RENTAL_MANAGER, "Rental Manager"),
        (TENANT, "Tenant"),
        (GUEST_SUBMITTER, "Guest Submitter"),
    ]


class UserProfile(models.Model):
    """
    Per-user role (highest/global role) and optional condo affinity.
    Use UnitAccess for per-unit permissions.
    """
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")
    role = models.CharField(max_length=20, choices=Role.CHOICES, default=Role.GUEST)
    condo = models.ForeignKey(
        "core.Condo",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        help_text="Primary condo this user is associated with (optional).",
    )
    phone = models.CharField(max_length=50, blank=True, default="")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = "accounts_userprofile"
        verbose_name = "User Profile"
        verbose_name_plural = "User Profiles"

    def __str__(self) -> str:
        return f"{self.user} · {self.get_role_display()}"


class UnitAccess(models.Model):
    """
    Grants a user access/authority for a specific Unit.
    Useful when the owner uses a third-party rental manager to submit guests.
    """
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="unit_accesses")
    unit = models.ForeignKey("core.Unit", on_delete=models.CASCADE, related_name="accesses")
    access_type = models.CharField(max_length=20, choices=AccessType.CHOICES, default=AccessType.OWNER)
    active = models.BooleanField(default=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = "accounts_unitaccess"
        unique_together = [("user", "unit", "access_type")]
        verbose_name = "Unit Access"
        verbose_name_plural = "Unit Access"

    def __str__(self) -> str:
        return f"{self.user} ↔ {self.unit} ({self.get_access_type_display()})"

================================================================================
FILE: accounts/permissions.py
================================================================================
# accounts/permissions.py
from rest_framework.permissions import BasePermission, SAFE_METHODS

def _role(user):
    return getattr(getattr(user, "profile", None), "role", None)

class IsAuthenticatedJWT(BasePermission):
    """
    Works with DRF SimpleJWT. If JWT auth is configured in REST_FRAMEWORK,
    request.user will be authenticated when a valid token is provided.
    """
    def has_permission(self, request, view):
        return bool(getattr(request, "user", None) and request.user.is_authenticated)

class ReadOnly(BasePermission):
    def has_permission(self, request, view):
        return request.method in SAFE_METHODS

class IsPropertyManager(BasePermission):
    def has_permission(self, request, view):
        return _role(request.user) == "pm"

class IsConcierge(BasePermission):
    def has_permission(self, request, view):
        return _role(request.user) == "con"

class IsAgent(BasePermission):
    """Third-party rental manager."""
    def has_permission(self, request, view):
        return _role(request.user) == "agent"

class IsOwner(BasePermission):
    def has_permission(self, request, view):
        return _role(request.user) == "own"

================================================================================
FILE: accounts/serializers.py
================================================================================
# accounts/serializers.py
from django.contrib.auth import get_user_model
from rest_framework import serializers

from .models import UserProfile, UnitAccess, Role

User = get_user_model()


class UserProfileSerializer(serializers.ModelSerializer):
    username = serializers.CharField(source="user.username", read_only=True)
    email = serializers.EmailField(source="user.email", read_only=True)

    class Meta:
        model = UserProfile
        fields = ["username", "email", "role"]


class UnitAccessSerializer(serializers.ModelSerializer):
    user = serializers.PrimaryKeyRelatedField(queryset=User.objects.all())
    unit = serializers.PrimaryKeyRelatedField(read_only=False)

    class Meta:
        model = UnitAccess
        fields = ["id", "user", "unit", "access_type", "created_at"]
        read_only_fields = ["id", "created_at"]

================================================================================
FILE: ci_touch.txt
================================================================================
# trigger CI again

================================================================================
FILE: condo_backend/__init__.py
================================================================================


================================================================================
FILE: condo_backend/asgi.py
================================================================================
"""
ASGI config for condo_backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "condo_backend.settings")

application = get_asgi_application()

================================================================================
FILE: condo_backend/settings.py
================================================================================
"""
Django settings for condo_backend project.
"""
import os
from datetime import timedelta
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

DOTENV_PATH = BASE_DIR / ".env"
if DOTENV_PATH.exists():
    try:
        from dotenv import load_dotenv
        load_dotenv(DOTENV_PATH)
    except Exception:
        pass

DEBUG = os.getenv("DEBUG", "True") == "True"
SECRET_KEY = os.getenv("SECRET_KEY", "dev-only-not-secure")
ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "*").split(",")
CSRF_TRUSTED_ORIGINS = (
    os.getenv("CSRF_TRUSTED_ORIGINS", "").split(",")
    if os.getenv("CSRF_TRUSTED_ORIGINS")
    else []
)

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # Third-party
    "rest_framework",
    "corsheaders",
    "django_filters",
    "drf_spectacular",  # <— docs

    # Local
    "accounts",
    "core",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "condo_backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "condo_backend.wsgi.application"

# Database
if os.getenv("DB_ENGINE") == "postgres":
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.postgresql",
            "NAME": os.getenv("DB_NAME", "app"),
            "USER": os.getenv("DB_USER", "app"),
            "PASSWORD": os.getenv("DB_PASSWORD", ""),
            "HOST": os.getenv("DB_HOST", "localhost"),
            "PORT": os.getenv("DB_PORT", "5432"),
        }
    }
else:
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }

AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

LANGUAGE_CODE = "en-us"
TIME_ZONE = "UTC"
USE_I18N = True
USE_TZ = True

STATIC_URL = "static/"
STATIC_ROOT = BASE_DIR / "staticfiles"

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ),
    "DEFAULT_PERMISSION_CLASSES": (
        "rest_framework.permissions.IsAuthenticated",
    ),
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
    "DEFAULT_FILTER_BACKENDS": [
        "django_filters.rest_framework.DjangoFilterBackend",
    ],
    # OpenAPI
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
}

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=30),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
}

# drf-spectacular settings (defaults are fine; tweak later)
SPECTACULAR_SETTINGS = {
    "TITLE": "Condo Backend API",
    "DESCRIPTION": "Parking assignments, short-term bookings, and RBAC.",
    "VERSION": "1.0.0",
    "SERVERS": [{"url": "http://localhost:8000"}],
    "SWAGGER_UI_DIST": "SIDECAR",  # use drf-spectacular-sidecar
    "SWAGGER_UI_FAVICON_HREF": "SIDECAR",
    "REDOC_DIST": "SIDECAR",
}

CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

SECURE_BROWSER_XSS_FILTER = True
SESSION_COOKIE_SECURE = False if DEBUG else True
CSRF_COOKIE_SECURE = False if DEBUG else True

================================================================================
FILE: condo_backend/urls.py
================================================================================
from django.contrib import admin
from django.urls import path, include
from django.http import JsonResponse, HttpResponse
from django.conf import settings
from django.conf.urls.static import static

# API schema / docs
from drf_spectacular.views import (
    SpectacularAPIView,
    SpectacularRedocView,
    SpectacularSwaggerView,
)

# JWT auth
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

def home(_request):
    return HttpResponse("Condo backend is running")

def ping(_request):
    return JsonResponse({"pong": True})

def health(_request):
    return JsonResponse({"ok": True})

urlpatterns = [
    path("", home),
    path("api/healthz", health),
    path("api/ping", ping),

    # Core API (includes your viewsets + CSV endpoints)
    path("api/", include("core.urls")),

    # --- Auth (JWT) ---
    path("api/auth/token/", TokenObtainPairView.as_view(), name="token_obtain_pair"),
    path("api/auth/token/refresh/", TokenRefreshView.as_view(), name="token_refresh"),

    # --- OpenAPI / Docs ---
    path("api/schema/", SpectacularAPIView.as_view(), name="schema"),
    path("api/docs/", SpectacularSwaggerView.as_view(url_name="schema"), name="swagger-ui"),
    path("api/redoc/", SpectacularRedocView.as_view(url_name="schema"), name="redoc"),

    path("admin/", admin.site.urls),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

================================================================================
FILE: condo_backend/wsgi.py
================================================================================
"""
WSGI config for condo_backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "condo_backend.settings")

application = get_wsgi_application()

================================================================================
FILE: core/__init__.py
================================================================================


================================================================================
FILE: core/admin.py
================================================================================
from django.contrib import admin
from .models import Condo, Unit, ParkingSpot, UnitParkingAssignment, ShortTermBooking

@admin.register(Condo)
class CondoAdmin(admin.ModelAdmin):
    list_display = ("id", "code", "name")
    search_fields = ("code", "name")


@admin.register(Unit)
class UnitAdmin(admin.ModelAdmin):
    # your Unit model uses 'unit_number' (not 'number')
    list_display = ("id", "unit_number", "condo")
    list_filter = ("condo",)
    search_fields = ("unit_number",)
    autocomplete_fields = ("condo",)


@admin.register(ParkingSpot)
class ParkingSpotAdmin(admin.ModelAdmin):
    # remove 'status' – your ParkingSpot model doesn’t have it
    list_display = ("id", "code", "condo", "level", "spot_type")
    list_filter = ("condo", "spot_type", "level")
    search_fields = ("code",)
    autocomplete_fields = ("condo",)


@admin.register(UnitParkingAssignment)
class UnitParkingAssignmentAdmin(admin.ModelAdmin):
    # your FK is 'parking_spot' (not 'spot'); remove fields that don’t exist
    list_display = ("id", "unit", "parking_spot", "start_date", "end_date", "is_primary")
    list_filter = ("unit__condo", "is_primary")
    search_fields = ("unit__unit_number", "parking_spot__code")
    autocomplete_fields = ("unit", "parking_spot")


@admin.register(ShortTermBooking)
class ShortTermBookingAdmin(admin.ModelAdmin):
    # booking uses 'unit', 'parking_spot', guest_first_name/guest_last_name
    list_display = ("id", "unit", "parking_spot", "guest_first_name", "guest_last_name", "check_in", "check_out")
    list_filter = ("unit__condo",)  # keep minimal; add 'status' or 'id_type' only if they exist on your model
    search_fields = ("guest_first_name", "guest_last_name", "vehicle_plate", "unit__unit_number", "parking_spot__code")
    autocomplete_fields = ("unit", "parking_spot")

================================================================================
FILE: core/apps.py
================================================================================
from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"

================================================================================
FILE: core/filters.py
================================================================================
# core/filters.py
import django_filters
from .models import ShortTermBooking


class ShortTermBookingFilter(django_filters.FilterSet):
    check_in_after = django_filters.DateFilter(field_name="check_in", lookup_expr="gte")
    check_in_before = django_filters.DateFilter(field_name="check_in", lookup_expr="lte")
    check_out_after = django_filters.DateFilter(field_name="check_out", lookup_expr="gte")
    check_out_before = django_filters.DateFilter(field_name="check_out", lookup_expr="lte")

    class Meta:
        model = ShortTermBooking
        fields = [
            "unit",
            "parking_spot",
            "status",
            "check_in_after",
            "check_in_before",
            "check_out_after",
            "check_out_before",
        ]

================================================================================
FILE: core/fixtures/sample_data.json
================================================================================
[
  {
    "model": "core.condo",
    "pk": 1,
    "fields": {
      "code": "TSCC1848",
      "name": "TSCC 1848",
      "city": "Toronto",
      "province": "ON",
      "created_at": "2025-01-01T00:00:00Z",
      "updated_at": "2025-01-01T00:00:00Z"
    }
  },
  {
    "model": "core.unit",
    "pk": 1,
    "fields": {
      "condo": 1,
      "unit_number": "905",
      "owner_name": "Alex Owner",
      "owner_email": "alex@example.com",
      "status": "OWNER_OCCUPIED",
      "created_at": "2025-01-01T00:05:00Z",
      "updated_at": "2025-01-01T00:05:00Z"
    }
  },
  {
    "model": "core.unit",
    "pk": 2,
    "fields": {
      "condo": 1,
      "unit_number": "1001",
      "owner_name": "Blair Owner",
      "owner_email": "blair@example.com",
      "status": "OWNER_OCCUPIED",
      "created_at": "2025-01-01T00:06:00Z",
      "updated_at": "2025-01-01T00:06:00Z"
    }
  },
  {
    "model": "core.parkingspot",
    "pk": 1,
    "fields": {
      "condo": 1,
      "code": "P1-001",
      "level": "P1",
      "spot_type": "RESIDENT",
      "created_at": "2025-01-01T00:10:00Z",
      "updated_at": "2025-01-01T00:10:00Z"
    }
  },
  {
    "model": "core.parkingspot",
    "pk": 2,
    "fields": {
      "condo": 1,
      "code": "P1-002",
      "level": "P1",
      "spot_type": "RESIDENT",
      "created_at": "2025-01-01T00:11:00Z",
      "updated_at": "2025-01-01T00:11:00Z"
    }
  },
  {
    "model": "core.unitparkingassignment",
    "pk": 1,
    "fields": {
      "unit": 1,
      "parking_spot": 1,
      "start_date": "2025-01-01",
      "end_date": null,
      "is_primary": true,
      "created_at": "2025-01-01T00:15:00Z",
      "updated_at": "2025-01-01T00:15:00Z"
    }
  },
  {
    "model": "core.unitparkingassignment",
    "pk": 2,
    "fields": {
      "unit": 2,
      "parking_spot": 2,
      "start_date": "2025-01-01",
      "end_date": null,
      "is_primary": true,
      "created_at": "2025-01-01T00:16:00Z",
      "updated_at": "2025-01-01T00:16:00Z"
    }
  },
  {
    "model": "core.shorttermbooking",
    "pk": 1,
    "fields": {
      "unit": 1,
      "parking_spot": 1,
      "guest_first_name": "Casey",
      "guest_last_name": "Guest",
      "id_type": "LICENSE",
      "id_number": "A1234567",
      "id_country": "CA",
      "id_province_state": "ON",
      "vehicle_plate": "ABCX123",
      "check_in": "2025-09-16",
      "check_out": "2025-09-16",
      "status": "pending",
      "notes": "fixture booking",
      "created_at": "2025-01-01T00:20:00Z",
      "updated_at": "2025-01-01T00:20:00Z"
    }
  }
]

================================================================================
FILE: core/management/commands/check_csv_roundtrip.py
================================================================================
from django.core.management.base import BaseCommand
from django.utils import timezone
from core.models import UnitParkingAssignment

class Command(BaseCommand):
    help = "Sanity check: every active assignment links a unit to a parking spot and vice versa"

    def handle(self, *args, **kwargs):
        missing = []
        for a in UnitParkingAssignment.objects.select_related("unit", "parking_spot"):
            if not a.unit_id or not a.parking_spot_id:
                missing.append(a.pk)
        if missing:
            self.stderr.write(f"Incomplete assignments (no unit or no spot): {missing}")
            raise SystemExit(1)
        self.stdout.write(self.style.SUCCESS("Assignment round-trip looks good."))

================================================================================
FILE: core/management/commands/export_assignments_csv.py
================================================================================
from django.core.management.base import BaseCommand
from pathlib import Path
from core.services.csv_assignments import export_all_assignments

class Command(BaseCommand):
    help = "Export Unit↔Parking assignments to CSV."

    def add_arguments(self, parser):
        parser.add_argument("--out", default="exports/assignments.csv", help="Output CSV path")

    def handle(self, *args, **opts):
        out = Path(opts["out"])
        out.parent.mkdir(parents=True, exist_ok=True)
        csv_text = export_all_assignments()
        out.write_text(csv_text, encoding="utf-8")
        self.stdout.write(self.style.SUCCESS(f"Wrote {out} ({len(csv_text)} bytes)"))

================================================================================
FILE: core/management/commands/import_assignments_csv.py
================================================================================
from django.core.management.base import BaseCommand, CommandError
from pathlib import Path
from core.services.csv_assignments import import_assignments_csv

class Command(BaseCommand):
    help = "Import/Upsert Unit↔Parking assignments from CSV."

    def add_arguments(self, parser):
        parser.add_argument("csv_path", help="Path to CSV file")

    def handle(self, *args, **opts):
        p = Path(opts["csv_path"])
        if not p.exists():
            raise CommandError(f"File not found: {p}")
        changed, warnings = import_assignments_csv(p.read_text(encoding="utf-8"))
        for w in warnings:
            self.stderr.write(w)
        self.stdout.write(self.style.SUCCESS(f"Imported/updated rows: {changed}"))

================================================================================
FILE: core/management/commands/load_sample_data.py
================================================================================
from django.core.management.base import BaseCommand, CommandError
from django.core.management import call_command
from django.apps import apps
from pathlib import Path

class Command(BaseCommand):
    help = "Load sample data fixtures for local/CI runs"

    def add_arguments(self, parser):
        parser.add_argument("--flush", action="store_true", help="Flush DB before loading fixtures")

    def handle(self, *args, **opts):
        core_path = Path(apps.get_app_config("core").path)
        fixture_path = core_path / "fixtures" / "sample_data.json"
        if not fixture_path.exists():
            raise CommandError(f"Fixture not found: {fixture_path}")

        if opts["flush"]:
            self.stdout.write("Flushing database...")
            call_command("flush", interactive=False)

        self.stdout.write(f"Loading fixture: {fixture_path}")
        call_command("loaddata", str(fixture_path))
        self.stdout.write(self.style.SUCCESS("Sample data loaded."))

================================================================================
FILE: core/migrations/0001_initial.py
================================================================================
# Generated by Django 5.2.6 on 2025-09-09 19:30

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Condo",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("name", models.CharField(max_length=200)),
                ("address", models.CharField(blank=True, max_length=255)),
                ("city", models.CharField(blank=True, max_length=100)),
                ("province", models.CharField(blank=True, max_length=50)),
                ("code", models.CharField(blank=True, max_length=50)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
            ],
            options={
                "ordering": ["name"],
            },
        ),
    ]

================================================================================
FILE: core/migrations/0002_unit.py
================================================================================
# Generated by Django 5.2.6 on 2025-09-09 20:16

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0001_initial"),
    ]

    operations = [
        migrations.CreateModel(
            name="Unit",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("unit_number", models.CharField(max_length=20)),
                ("owner_name", models.CharField(blank=True, max_length=200)),
                ("owner_email", models.EmailField(blank=True, max_length=254)),
                ("status", models.CharField(blank=True, max_length=30)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "condo",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="units",
                        to="core.condo",
                    ),
                ),
            ],
            options={
                "ordering": ["condo__name", "unit_number"],
                "unique_together": {("condo", "unit_number")},
            },
        ),
    ]

================================================================================
FILE: core/migrations/0003_parkingspot_shorttermbooking_unitparkingassignment.py
================================================================================
# Generated by Django 5.2.6 on 2025-09-09 20:29

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0002_unit"),
    ]

    operations = [
        migrations.CreateModel(
            name="ParkingSpot",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("code", models.CharField(max_length=50)),
                ("level", models.CharField(blank=True, max_length=50)),
                ("spot_type", models.CharField(blank=True, max_length=30)),
                ("notes", models.TextField(blank=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "condo",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="parking_spots",
                        to="core.condo",
                    ),
                ),
            ],
            options={
                "ordering": ["condo__name", "code"],
                "unique_together": {("condo", "code")},
            },
        ),
        migrations.CreateModel(
            name="ShortTermBooking",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("guest_first_name", models.CharField(max_length=100)),
                ("guest_last_name", models.CharField(max_length=100)),
                ("guest_email", models.EmailField(blank=True, max_length=254)),
                ("guest_phone", models.CharField(blank=True, max_length=50)),
                (
                    "id_type",
                    models.CharField(
                        choices=[
                            ("DL", "Driver License"),
                            ("PASS", "Passport"),
                            ("NID", "National ID"),
                            ("OTHER", "Other"),
                        ],
                        default="DL",
                        max_length=10,
                    ),
                ),
                ("id_number", models.CharField(max_length=100)),
                ("id_country", models.CharField(blank=True, max_length=100)),
                ("id_province_state", models.CharField(blank=True, max_length=100)),
                ("id_city", models.CharField(blank=True, max_length=100)),
                ("check_in", models.DateTimeField()),
                ("check_out", models.DateTimeField()),
                ("num_guests", models.PositiveIntegerField(default=1)),
                ("vehicle_plate", models.CharField(blank=True, max_length=30)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("approved", "Approved"),
                            ("rejected", "Rejected"),
                            ("cancelled", "Cancelled"),
                            ("completed", "Completed"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
                ("created_by_email", models.EmailField(blank=True, max_length=254)),
                ("approved_by", models.CharField(blank=True, max_length=150)),
                ("approved_at", models.DateTimeField(blank=True, null=True)),
                ("notes", models.TextField(blank=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "parking_spot",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.SET_NULL,
                        to="core.parkingspot",
                    ),
                ),
                (
                    "unit",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="str_bookings",
                        to="core.unit",
                    ),
                ),
            ],
            options={
                "ordering": ["-check_in"],
            },
        ),
        migrations.CreateModel(
            name="UnitParkingAssignment",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("start_date", models.DateField()),
                ("end_date", models.DateField(blank=True, null=True)),
                ("is_primary", models.BooleanField(default=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "parking_spot",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.PROTECT,
                        related_name="assignments",
                        to="core.parkingspot",
                    ),
                ),
                (
                    "unit",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="parking_assignments",
                        to="core.unit",
                    ),
                ),
            ],
            options={
                "ordering": ["unit__condo__name", "unit__unit_number", "-start_date"],
            },
        ),
    ]

================================================================================
FILE: core/migrations/0004_alter_shorttermbooking_dates_to_datefield.py
================================================================================
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0003_parkingspot_shorttermbooking_unitparkingassignment"),
    ]

    operations = [
        migrations.AlterField(
            model_name="shorttermbooking",
            name="check_in",
            field=models.DateField(),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="check_out",
            field=models.DateField(),
        ),
    ]

================================================================================
FILE: core/migrations/0005_safe_cleanup_and_updated_at.py
================================================================================
from django.db import migrations, models
from django.utils import timezone


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0004_alter_shorttermbooking_dates_to_datefield"),
    ]

    operations = [
        # Add updated_at to all models (aligns with your models.py)
        migrations.AddField(
            model_name="condo",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="unit",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="parkingspot",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="unitparkingassignment",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="shorttermbooking",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),

        # Don’t try to DROP columns in SQLite that never existed.
        # Update Django state only so future migrations stay consistent.
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.RemoveField(model_name="parkingspot", name="notes"),
                migrations.RemoveField(model_name="shorttermbooking", name="approved_at"),
                migrations.RemoveField(model_name="shorttermbooking", name="approved_by"),
                migrations.RemoveField(model_name="shorttermbooking", name="created_by_email"),
                migrations.RemoveField(model_name="shorttermbooking", name="guest_email"),
                migrations.RemoveField(model_name="shorttermbooking", name="guest_phone"),
                migrations.RemoveField(model_name="shorttermbooking", name="id_city"),
                migrations.RemoveField(model_name="shorttermbooking", name="num_guests"),
            ]
        ),
    ]

================================================================================
FILE: core/migrations/0006_remove_parkingspot_notes_db.py
================================================================================
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0005_safe_cleanup_and_updated_at"),
    ]

    operations = [
        # Make Django aware of the field again (state only; no DB change here).
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddField(
                    model_name="parkingspot",
                    name="notes",
                    field=models.TextField(blank=True, null=True, default=""),
                ),
            ],
            database_operations=[],
        ),
        # Now actually drop it (SQLite will recreate the table).
        migrations.RemoveField(
            model_name="parkingspot",
            name="notes",
        ),
    ]

================================================================================
FILE: core/migrations/0007_drop_shorttermbooking_legacy_columns_db.py
================================================================================
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0006_remove_parkingspot_notes_db"),
    ]

    operations = [
        # 1) Re-introduce legacy fields in *state only* so Django "knows" them.
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="approved_at",
                    field=models.DateTimeField(null=True, blank=True, default=None),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="approved_by",
                    field=models.CharField(max_length=255, null=True, blank=True, default=""),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="created_by_email",
                    field=models.CharField(max_length=255, null=True, blank=True, default=""),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="guest_email",
                    field=models.CharField(max_length=255, null=True, blank=True, default=""),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="guest_phone",
                    field=models.CharField(max_length=50, null=True, blank=True, default=""),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="id_city",
                    field=models.CharField(max_length=255, null=True, blank=True, default=""),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="num_guests",
                    field=models.IntegerField(null=True, blank=True, default=None),
                ),
            ],
            database_operations=[],
        ),

        # 2) Now actually remove them (DB operation). On SQLite this rebuilds the table
        # without these columns, eliminating NOT NULL constraints left behind.
        migrations.RemoveField(model_name="shorttermbooking", name="approved_at"),
        migrations.RemoveField(model_name="shorttermbooking", name="approved_by"),
        migrations.RemoveField(model_name="shorttermbooking", name="created_by_email"),
        migrations.RemoveField(model_name="shorttermbooking", name="guest_email"),
        migrations.RemoveField(model_name="shorttermbooking", name="guest_phone"),
        migrations.RemoveField(model_name="shorttermbooking", name="id_city"),
        migrations.RemoveField(model_name="shorttermbooking", name="num_guests"),
    ]

================================================================================
FILE: core/migrations/0008_booking_workflow_and_file.py
================================================================================
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    # Make 0008 depend on 0007 to linearize the graph.
    dependencies = [
        ("core", "0007_drop_shorttermbooking_legacy_columns_db"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        # Workflow fields
        migrations.AddField(
            model_name="shorttermbooking",
            name="submitted_by",
            field=models.ForeignKey(
                to=settings.AUTH_USER_MODEL,
                on_delete=django.db.models.deletion.SET_NULL,
                null=True,
                blank=True,
                related_name="bookings_submitted",
            ),
        ),
        migrations.AddField(
            model_name="shorttermbooking",
            name="reviewed_by",
            field=models.ForeignKey(
                to=settings.AUTH_USER_MODEL,
                on_delete=django.db.models.deletion.SET_NULL,
                null=True,
                blank=True,
                related_name="bookings_reviewed",
            ),
        ),
        migrations.AddField(
            model_name="shorttermbooking",
            name="reviewed_at",
            field=models.DateTimeField(null=True, blank=True),
        ),
        # Optional ID upload
        migrations.AddField(
            model_name="shorttermbooking",
            name="id_document",
            field=models.FileField(upload_to="ids/", null=True, blank=True),
        ),
        # Normalize statuses (lowercase)
        migrations.AlterField(
            model_name="shorttermbooking",
            name="status",
            field=models.CharField(
                max_length=16,
                choices=[
                    ("pending", "Pending"),
                    ("approved", "Approved"),
                    ("rejected", "Rejected"),
                    ("cancelled", "Cancelled"),
                ],
                default="pending",
            ),
        ),
    ]

================================================================================
FILE: core/migrations/__init__.py
================================================================================


================================================================================
FILE: core/models.py
================================================================================
# core/models.py
from django.conf import settings
from django.db import models


class TimeStampedModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    class Meta:
        abstract = True


class Condo(TimeStampedModel):
    name = models.CharField(max_length=200)
    code = models.CharField(max_length=50, unique=True)  # short identifier
    address = models.CharField(max_length=255, blank=True)
    city = models.CharField(max_length=120, blank=True)
    province = models.CharField(max_length=120, blank=True)

    def __str__(self) -> str:
        return f"{self.name} ({self.code})"


class Unit(TimeStampedModel):
    class Status(models.TextChoices):
        OWNER_OCCUPIED = "OWNER_OCCUPIED", "Owner Occupied"
        TENANT = "TENANT", "Tenant"
        VACANT = "VACANT", "Vacant"

    condo = models.ForeignKey(Condo, on_delete=models.CASCADE, related_name="units")
    unit_number = models.CharField(max_length=50)
    owner_name = models.CharField(max_length=200, blank=True)
    owner_email = models.EmailField(blank=True)
    status = models.CharField(max_length=32, choices=Status.choices, default=Status.OWNER_OCCUPIED)

    class Meta:
        unique_together = ("condo", "unit_number")

    def __str__(self) -> str:
        return f"{self.condo.code}-{self.unit_number}"


class ParkingSpot(TimeStampedModel):
    class SpotType(models.TextChoices):
        RESIDENT = "RESIDENT", "Resident"
        VISITOR = "VISITOR", "Visitor"

    condo = models.ForeignKey(Condo, on_delete=models.CASCADE, related_name="parking_spots")
    code = models.CharField(max_length=50)  # e.g., P1-123
    level = models.CharField(max_length=50, blank=True)
    spot_type = models.CharField(max_length=16, choices=SpotType.choices, default=SpotType.RESIDENT)

    class Meta:
        unique_together = ("condo", "code")

    def __str__(self) -> str:
        return f"{self.condo.code}-{self.code}"


class UnitParkingAssignment(TimeStampedModel):
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name="parking_assignments")
    parking_spot = models.ForeignKey(ParkingSpot, on_delete=models.CASCADE, related_name="assignments")
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)  # open-ended
    is_primary = models.BooleanField(default=True)

    class Meta:
        ordering = ["-start_date"]

    def __str__(self) -> str:
        return f"{self.unit} → {self.parking_spot}"


class ShortTermBooking(TimeStampedModel):
    class IdType(models.TextChoices):
        LICENSE = "LICENSE", "Driver’s License"
        PASSPORT = "PASSPORT", "Passport"
        OTHER = "OTHER", "Other"

    # lower-case to match views (.approve/.reject) and serializer
    class Status(models.TextChoices):
        PENDING = "pending", "Pending"
        APPROVED = "approved", "Approved"
        REJECTED = "rejected", "Rejected"
        CANCELLED = "cancelled", "Cancelled"

    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name="bookings")

    # guest info
    guest_first_name = models.CharField(max_length=120)
    guest_last_name = models.CharField(max_length=120)
    id_type = models.CharField(max_length=16, choices=IdType.choices, default=IdType.LICENSE)
    id_number = models.CharField(max_length=120, blank=True)
    id_country = models.CharField(max_length=120, blank=True)
    id_province_state = models.CharField(max_length=120, blank=True)

    # vehicle & parking
    vehicle_plate = models.CharField(max_length=50, blank=True)
    parking_spot = models.ForeignKey(
        ParkingSpot, on_delete=models.SET_NULL, null=True, blank=True, related_name="bookings"
    )

    # stay dates (date granularity is fine)
    check_in = models.DateField()
    check_out = models.DateField()

    status = models.CharField(max_length=16, choices=Status.choices, default=Status.PENDING)
    notes = models.TextField(blank=True)

    # RBAC workflow tracking (matches serializer)
    submitted_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True, related_name="bookings_submitted"
    )
    reviewed_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True, related_name="bookings_reviewed"
    )
    reviewed_at = models.DateTimeField(null=True, blank=True)

    # optional file upload for ID image/PDF
    id_document = models.FileField(upload_to="ids/", null=True, blank=True)

    class Meta:
        ordering = ["-check_in"]

    def __str__(self) -> str:
        return f"Booking {self.unit} {self.check_in}→{self.check_out} ({self.status})"

================================================================================
FILE: core/serializers.py
================================================================================
# core/serializers.py
from django.contrib.auth import get_user_model
from rest_framework import serializers
from .models import Condo, Unit, ParkingSpot, UnitParkingAssignment, ShortTermBooking

User = get_user_model()


class CondoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Condo
        fields = "__all__"


class UnitSerializer(serializers.ModelSerializer):
    condo_name = serializers.CharField(source="condo.name", read_only=True)

    class Meta:
        model = Unit
        fields = [
            "id",
            "condo",
            "condo_name",
            "unit_number",
            "owner_name",
            "owner_email",
            "status",
            "created_at",
            "updated_at",
        ]


class ParkingSpotSerializer(serializers.ModelSerializer):
    condo_name = serializers.CharField(source="condo.name", read_only=True)

    class Meta:
        model = ParkingSpot
        fields = [
            "id",
            "condo",
            "condo_name",
            "code",
            "level",
            "spot_type",
            "created_at",
            "updated_at",
        ]


class UnitParkingAssignmentSerializer(serializers.ModelSerializer):
    unit_display = serializers.CharField(source="unit.__str__", read_only=True)
    spot_display = serializers.CharField(source="parking_spot.__str__", read_only=True)

    class Meta:
        model = UnitParkingAssignment
        fields = [
            "id",
            "unit",
            "unit_display",
            "parking_spot",
            "spot_display",
            "start_date",
            "end_date",
            "is_primary",
            "created_at",
            "updated_at",
        ]

    def validate(self, attrs):
        unit = attrs.get("unit") or getattr(self.instance, "unit", None)
        spot = attrs.get("parking_spot") or getattr(self.instance, "parking_spot", None)
        if unit and spot and unit.condo_id != spot.condo_id:
            raise serializers.ValidationError("Unit and Parking Spot must belong to the same condo.")
        return attrs


class ShortTermBookingSerializer(serializers.ModelSerializer):
    unit_display = serializers.CharField(source="unit.__str__", read_only=True)
    spot_display = serializers.CharField(source="parking_spot.__str__", read_only=True)

    # RBAC workflow fields
    submitted_by_username = serializers.CharField(source="submitted_by.username", read_only=True)
    reviewed_by_username = serializers.CharField(source="reviewed_by.username", read_only=True)
    id_document = serializers.FileField(required=False, allow_null=True)

    class Meta:
        model = ShortTermBooking
        fields = [
            "id",
            "unit",
            "unit_display",
            "guest_first_name",
            "guest_last_name",
            "id_type",
            "id_number",
            "id_country",
            "id_province_state",
            "vehicle_plate",
            "parking_spot",
            "spot_display",
            "check_in",
            "check_out",
            "status",
            "notes",
            "id_document",
            "submitted_by",
            "submitted_by_username",
            "reviewed_by",
            "reviewed_by_username",
            "reviewed_at",
            "created_at",
            "updated_at",
        ]
        read_only_fields = [
            "id",
            "submitted_by",
            "submitted_by_username",
            "reviewed_by",
            "reviewed_by_username",
            "reviewed_at",
            "created_at",
            "updated_at",
        ]

    def validate(self, attrs):
        check_in = attrs.get("check_in") or getattr(self.instance, "check_in", None)
        check_out = attrs.get("check_out") or getattr(self.instance, "check_out", None)
        if check_in and check_out and check_out < check_in:
            raise serializers.ValidationError("check_out must be the same day or after check_in.")

        unit = attrs.get("unit") or getattr(self.instance, "unit", None)
        spot = attrs.get("parking_spot") or getattr(self.instance, "parking_spot", None)
        if unit and spot and unit.condo_id != spot.condo_id:
            raise serializers.ValidationError("Selected parking spot must belong to the same condo as the unit.")
        return attrs

    def create(self, validated_data):
        # record who submitted (owner/agent/concierge/pm)
        user = self.context["request"].user if "request" in self.context else None
        if user and user.is_authenticated:
            validated_data["submitted_by"] = user
        return super().create(validated_data)

================================================================================
FILE: core/tests/test_fixture_smoke.py
================================================================================
from django.test import TestCase
from core.models import Condo, Unit, ParkingSpot, UnitParkingAssignment, ShortTermBooking

class FixtureSmokeTests(TestCase):
    fixtures = ["sample_data.json"]

    def test_counts_and_linkage(self):
        self.assertEqual(Condo.objects.count(), 1)
        self.assertEqual(Unit.objects.count(), 2)
        self.assertEqual(ParkingSpot.objects.count(), 2)
        self.assertEqual(UnitParkingAssignment.objects.count(), 2)
        # linkage: confirm each unit has a spot via assignment
        a1 = UnitParkingAssignment.objects.get(unit__unit_number="905")
        self.assertIsNotNone(a1.parking_spot_id)
        # bookings fixture present
        self.assertEqual(ShortTermBooking.objects.count(), 1)

================================================================================
FILE: core/tests.py
================================================================================
from django.test import TestCase
from django.apps import apps

class SmokeTest(TestCase):
    def test_core_app_loaded(self):
        self.assertTrue(apps.is_installed("core"))

================================================================================
FILE: core/urls.py
================================================================================
from django.urls import path, include
from rest_framework.routers import DefaultRouter

from .views import (
    CondoViewSet, UnitViewSet, ParkingSpotViewSet,
    UnitParkingAssignmentViewSet, ShortTermBookingViewSet
)
from .views_assignments_csv import AssignmentsCSVExportView, AssignmentsCSVImportView

router = DefaultRouter()
router.register(r"condos", CondoViewSet, basename="condo")
router.register(r"units", UnitViewSet, basename="unit")
router.register(r"parking-spots", ParkingSpotViewSet, basename="parkingspot")
router.register(r"unit-parking-assignments", UnitParkingAssignmentViewSet, basename="unitparkingassignment")
router.register(r"bookings", ShortTermBookingViewSet, basename="booking")

urlpatterns = [
    path("", include(router.urls)),
    path("assignments/export.csv", AssignmentsCSVExportView.as_view()),
    path("assignments/import.csv", AssignmentsCSVImportView.as_view()),
]

================================================================================
FILE: core/views.py
================================================================================
# core/views.py
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response

from accounts.models import Role, UnitAccess
from accounts.permissions import (
    IsAuthenticatedJWT, IsPropertyManager, IsConcierge, ReadOnly
)

from .models import Condo, Unit, ParkingSpot, UnitParkingAssignment, ShortTermBooking
from .serializers import (
    CondoSerializer,
    UnitSerializer,
    ParkingSpotSerializer,
    UnitParkingAssignmentSerializer,
    ShortTermBookingSerializer,
)
from .filters import ShortTermBookingFilter


# ----- helpers -----
def user_units_qs(user):
    """Units this user can access (PM: all; others via UnitAccess)."""
    if not user.is_authenticated:
        return Unit.objects.none()
    role = getattr(getattr(user, "profile", None), "role", None)
    if role == Role.PROPERTY_MANAGER:
        return Unit.objects.all()
    unit_ids = UnitAccess.objects.filter(user=user).values_list("unit_id", flat=True)
    return Unit.objects.filter(id__in=unit_ids)


# ----- viewsets -----
class CondoViewSet(viewsets.ModelViewSet):
    queryset = Condo.objects.all()
    serializer_class = CondoSerializer
    permission_classes = [IsAuthenticatedJWT & (IsPropertyManager | ReadOnly)]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["code", "city", "province"]
    ordering = ["code"]


class UnitViewSet(viewsets.ModelViewSet):
    serializer_class = UnitSerializer
    permission_classes = [IsAuthenticatedJWT & (IsPropertyManager | ReadOnly)]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["condo", "status", "unit_number"]
    ordering = ["unit_number"]

    def get_queryset(self):
        return user_units_qs(self.request.user).select_related("condo")


class ParkingSpotViewSet(viewsets.ModelViewSet):
    queryset = ParkingSpot.objects.select_related("condo").all()
    serializer_class = ParkingSpotSerializer
    permission_classes = [IsAuthenticatedJWT & (IsPropertyManager | ReadOnly)]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["condo", "spot_type", "level", "code"]
    ordering = ["code"]


class UnitParkingAssignmentViewSet(viewsets.ModelViewSet):
    serializer_class = UnitParkingAssignmentSerializer
    permission_classes = [IsAuthenticatedJWT & (IsPropertyManager | ReadOnly)]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["unit", "parking_spot", "is_primary", "unit__unit_number"]
    ordering = ["-start_date", "-created_at"]

    def get_queryset(self):
        units = user_units_qs(self.request.user)
        return (
            UnitParkingAssignment.objects
            .select_related("unit", "parking_spot")
            .filter(unit__in=units)
        )


class ShortTermBookingViewSet(viewsets.ModelViewSet):
    serializer_class = ShortTermBookingSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_class = ShortTermBookingFilter
    ordering = ["-check_in", "-created_at"]

    def get_permissions(self):
        """
        - PM: full access (list/create/update/delete + approve/reject).
        - Concierge: list/retrieve/update status (approve/reject). Cannot create/destroy.
        - Agent/Owner (via UnitAccess): can create & read their own bookings only.
        """
        role = getattr(getattr(self.request.user, "profile", None), "role", None)
        if role == Role.PROPERTY_MANAGER:
            return [IsAuthenticatedJWT()]
        if role == Role.CONCIERGE:
            if self.action in ["list", "retrieve", "update", "partial_update", "approve", "reject"]:
                return [IsAuthenticatedJWT()]
            return [IsAuthenticatedJWT(), ReadOnly()]
        # agents/owners
        if self.action in ["create", "list", "retrieve"]:
            return [IsAuthenticatedJWT()]
        return [IsAuthenticatedJWT(), ReadOnly()]

    def get_queryset(self):
        user = self.request.user
        role = getattr(getattr(user, "profile", None), "role", None)
        qs = ShortTermBooking.objects.select_related("unit", "parking_spot", "submitted_by", "reviewed_by")
        if role in [Role.PROPERTY_MANAGER, Role.CONCIERGE]:
            return qs
        units = user_units_qs(user)
        return qs.filter(unit__in=units)

    def perform_create(self, serializer):
        # agents/owners can only submit for units they have access to
        user = self.request.user
        role = getattr(getattr(user, "profile", None), "role", None)
        if role not in [Role.PROPERTY_MANAGER, Role.CONCIERGE]:
            unit = serializer.validated_data.get("unit")
            if unit not in list(user_units_qs(user)):
                raise permissions.PermissionDenied("No access to selected unit.")
        serializer.save()

    @action(detail=True, methods=["POST"])
    def approve(self, request, pk=None):
        booking = self.get_object()
        role = getattr(getattr(request.user, "profile", None), "role", None)
        if role not in [Role.PROPERTY_MANAGER, Role.CONCIERGE]:
            return Response({"detail": "Not allowed."}, status=status.HTTP_403_FORBIDDEN)
        booking.status = "approved"
        booking.reviewed_by = request.user
        from django.utils import timezone
        booking.reviewed_at = timezone.now()
        booking.save(update_fields=["status", "reviewed_by", "reviewed_at"])
        return Response(ShortTermBookingSerializer(booking, context={"request": request}).data)

    @action(detail=True, methods=["POST"])
    def reject(self, request, pk=None):
        booking = self.get_object()
        role = getattr(getattr(request.user, "profile", None), "role", None)
        if role not in [Role.PROPERTY_MANAGER, Role.CONCIERGE]:
            return Response({"detail": "Not allowed."}, status=status.HTTP_403_FORBIDDEN)
        booking.status = "rejected"
        booking.reviewed_by = request.user
        from django.utils import timezone
        booking.reviewed_at = timezone.now()
        booking.save(update_fields=["status", "reviewed_by", "reviewed_at"])
        return Response(ShortTermBookingSerializer(booking, context={"request": request}).data)

================================================================================
FILE: core/views_assignments_csv.py
================================================================================
# core/views_assignments_csv.py
from django.http import HttpResponse
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

from accounts.permissions import IsAuthenticatedJWT, IsPropertyManager
from .services.csv_assignments import export_assignments_to_csv, import_assignments_from_csv

class AssignmentsCSVExportView(APIView):
    permission_classes = [IsAuthenticatedJWT & IsPropertyManager]

    def get(self, request, *args, **kwargs):
        """
        Returns the current canonical assignments CSV as a file download.
        export_assignments_to_csv() must return (filename: str, content_bytes: bytes).
        """
        filename, content = export_assignments_to_csv()
        resp = HttpResponse(content, content_type="text/csv")
        resp["Content-Disposition"] = f'attachment; filename="{filename}"'
        return resp

class AssignmentsCSVImportView(APIView):
    permission_classes = [IsAuthenticatedJWT & IsPropertyManager]

    def post(self, request, *args, **kwargs):
        """
        Expect multipart/form-data with a 'file' field (CSV).
        """
        csv_file = request.FILES.get("file")
        if not csv_file:
            return Response({"detail": "Missing 'file'."}, status=status.HTTP_400_BAD_REQUEST)

        result = import_assignments_from_csv(csv_file)
        return Response(result, status=status.HTTP_200_OK)

================================================================================
FILE: export_repo_to_text.py
================================================================================
#!/usr/bin/env python3
"""
Export a codebase into a single *plain text* file for ChatGPT review.

Usage:
  python export_repo_to_text.py [OUTPUT_PATH]
                                [--max-bytes 200000]
                                [--include-sensitive]
                                [--include-binaries]
                                [--autocommit]
                                [--commit-message "msg"]
                                [--git-include-ignored]
                                [--git-init]

Defaults:
  OUTPUT_PATH: repo_dump.txt
  --max-bytes: 200000 (skip files larger than this; set 0 to disable size check)

Notes:
  - By default, file discovery uses `git ls-files` (tracked files only).
  - With --autocommit, we stage and commit first so new files are tracked.
  - Use --git-include-ignored to force-add ignored files too (careful: secrets).
  - Use --git-init to initialize a repo if none exists.
  - Falls back to walking the directory if Git is unavailable.
"""
from __future__ import annotations
import os
import sys
import subprocess
import time
from pathlib import Path
from typing import Iterable

ROOT = Path.cwd()

DEFAULT_MAX_BYTES = 200_000
DEFAULT_OUTPUT = "repo_dump.txt"

SKIP_NAMES = {".DS_Store", "Thumbs.db"}
SKIP_DIRS = {
    ".git", ".hg", ".svn", ".idea", ".vscode", ".venv", "venv", "__pycache__", "node_modules",
    "dist", "build", "staticfiles", ".pytest_cache", ".mypy_cache", ".ruff_cache",
}
SKIP_SUFFIXES = {
    ".pyc", ".pyo", ".pyd", ".so", ".dll", ".dylib",
    ".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg", ".ico",
    ".pdf", ".zip", ".tar", ".gz", ".bz2", ".xz", ".7z",
    ".mp3", ".wav", ".mp4", ".mov", ".avi",
    ".sqlite", ".sqlite3", ".db",
}
SENSITIVE_BASENAMES = {".env", ".env.local", ".envrc", ".secrets", "secrets.json"}


def sh(args, check=True, text=True):
    return subprocess.run(args, cwd=str(ROOT), stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=check, text=text)


def parse_args(argv):
    out_path = Path(DEFAULT_OUTPUT)
    max_bytes = DEFAULT_MAX_BYTES
    include_sensitive = False
    include_binaries = False
    autocommit = False
    commit_message = None
    git_include_ignored = False
    git_init = False

    i = 0
    if i < len(argv) and not argv[i].startswith("-"):
        out_path = Path(argv[i]); i += 1
    while i < len(argv):
        a = argv[i]
        if a == "--max-bytes" and i + 1 < len(argv):
            try:
                max_bytes = int(argv[i + 1])
            except ValueError:
                pass
            i += 2; continue
        if a == "--include-sensitive":
            include_sensitive = True; i += 1; continue
        if a == "--include-binaries":
            include_binaries = True; i += 1; continue
        if a == "--autocommit":
            autocommit = True; i += 1; continue
        if a == "--commit-message" and i + 1 < len(argv):
            commit_message = argv[i + 1]; i += 2; continue
        if a == "--git-include-ignored":
            git_include_ignored = True; i += 1; continue
        if a == "--git-init":
            git_init = True; i += 1; continue
        i += 1

    return (
        out_path, max_bytes, include_sensitive, include_binaries,
        autocommit, commit_message, git_include_ignored, git_init
    )


def ensure_git_repo(git_init: bool) -> bool:
    try:
        res = sh(["git", "rev-parse", "--is-inside-work-tree"])
        return res.stdout.strip() == "true"
    except Exception:
        if not git_init:
            return False
        try:
            sh(["git", "init"])
            print("[info] initialized new Git repository")
            return True
        except Exception as e:
            print(f"[warn] git init failed: {e}", file=sys.stderr)
            return False


def git_autocommit(commit_message: str | None, include_ignored: bool) -> None:
    """Stage and commit all changes locally. Uses inline identity so it never fails on missing config."""
    if not ensure_git_repo(git_init=False):
        # not a repo; nothing to do
        print("[info] not a Git repo; autocommit skipped")
        return
    try:
        # Stage everything normally
        sh(["git", "add", "-A"])
        # Optionally force-add ignored files too
        if include_ignored:
            # '.' ensures recursion; -f forces ignored files in
            sh(["git", "add", "-f", "."])
            # Also pick up currently-ignored tracked deletions/renames
            try:
                ignored = sh(["git", "ls-files", "-i", "--exclude-standard"]).stdout.splitlines()
                if ignored:
                    # Best-effort force add; ignore failures
                    sh(["git", "add", "-f"] + ignored, check=False)
            except Exception:
                pass

        # Show staged summary for diagnostics
        staged = sh(["git", "diff", "--cached", "--name-only"], check=False).stdout.strip()
        if not staged:
            print("[info] nothing staged; no commit made")
            return

        if not commit_message:
            ts = time.strftime("%Y-%m-%d %H:%M:%S")
            commit_message = f"auto-commit before export ({ts})"

        # Commit with inline identity so global config is not required
        res = sh([
            "git", "-c", "user.name=Repo Exporter",
            "-c", "user.email=exporter@local",
            "commit", "-m", commit_message
        ], check=False)
        if res.returncode != 0:
            print(res.stdout)
            print(res.stderr, file=sys.stderr)
            raise RuntimeError("git commit failed")
        print(f"[info] Auto-commit created with {len(staged.splitlines())} path(s).")
    except Exception as e:
        print(f"[warn] autocommit skipped: {e}", file=sys.stderr)


def iter_git_files() -> Iterable[Path]:
    try:
        res = sh(["git", "ls-files"])
        for line in res.stdout.splitlines():
            p = ROOT / line.strip()
            if p.is_file():
                yield p
    except Exception:
        # Fallback if Git not available
        for dirpath, dirnames, filenames in os.walk(ROOT):
            dirnames[:] = [d for d in dirnames if d not in SKIP_DIRS]
            for name in filenames:
                yield Path(dirpath) / name


def looks_binary(path: Path) -> bool:
    try:
        with open(path, "rb") as f:
            chunk = f.read(4096)
        return b"\x00" in chunk
    except Exception:
        return True


def should_skip(path: Path, include_sensitive: bool, include_binaries: bool) -> bool:
    if path.name in SKIP_NAMES:
        return True
    if not include_sensitive and path.name in SENSITIVE_BASENAMES:
        return True
    if any(part in SKIP_DIRS for part in path.parts):
        return True
    if not include_binaries and path.suffix.lower() in SKIP_SUFFIXES:
        return True
    return False


def write_binary_preview(out, path: Path):
    try:
        with open(path, "rb") as f:
            data = f.read(2048)
        out.write("[binary] first 2KB hex preview ({}) bytes:\n".format(len(data)))
        out.write(data.hex() + "\n")
    except Exception:
        out.write("[binary] <unreadable>\n")


def main():
    (
        out_path, max_bytes, include_sensitive, include_binaries,
        autocommit, commit_message, git_include_ignored, git_init
    ) = parse_args(sys.argv[1:])

    # Optionally initialize a repo
    if git_init and not ensure_git_repo(git_init=True):
        print("[warn] could not initialize Git; continuing without autocommit", file=sys.stderr)

    # Commit first if requested
    if autocommit:
        git_autocommit(commit_message, include_ignored=git_include_ignored)

    files = []
    for p in iter_git_files():
        try:
            rel = p.relative_to(ROOT)
        except Exception:
            rel = p
        if should_skip(rel, include_sensitive=include_sensitive, include_binaries=include_binaries):
            continue
        try:
            size = (ROOT / rel).stat().st_size
        except Exception:
            continue
        if max_bytes and size > max_bytes:
            continue
        files.append(rel)

    files.sort()

    sep = "=" * 80
    header = [
        "PROJECT EXPORT (plain text)",
        f"Root: {ROOT}",
        f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S %Z')}",
        f"Files included: {len(files)}",
        f"Max bytes per file: {max_bytes if max_bytes else 'no limit'}",
        f"include_sensitive: {include_sensitive}",
        f"include_binaries: {include_binaries}",
        f"autocommit: {autocommit}",
        f"git_include_ignored: {git_include_ignored}",
        "WARNING: If include_sensitive=True, secrets like .env are included in this export.",
        sep,
        "",
    ]
    out_path.write_text("\n".join(header), encoding="utf-8")

    with open(out_path, "a", encoding="utf-8", newline="\n") as out:
        for rel in files:
            abs_path = ROOT / rel
            out.write(f"\n{sep}\nFILE: {rel}\n{sep}\n")
            if include_binaries and looks_binary(abs_path):
                write_binary_preview(out, abs_path)
                continue
            try:
                text = abs_path.read_text(encoding="utf-8", errors="replace")
            except Exception:
                if include_binaries:
                    write_binary_preview(out, abs_path)
                continue
            out.write(text.rstrip("\n") + "\n")

    print(f"Wrote {out_path.resolve()} with {len(files)} files.")


if __name__ == "__main__":
    main()

================================================================================
FILE: exports/assignments.csv
================================================================================
condo_code,unit_number,spot_code,start_date,end_date,is_primary
TSCC1848,1001,P1-002,2025-01-01,,true
TSCC1848,905,P1-001,2025-01-01,,true

================================================================================
FILE: fixtures/sample_data.json
================================================================================
[
  {
    "model": "core.condo",
    "pk": 1,
    "fields": { "code": "TSCC1848", "name": "TSCC 1848" }
  },
  {
    "model": "core.unit",
    "pk": 1,
    "fields": { "condo": 1, "unit_number": "905", "owner_name": "Alex Owner", "owner_email": "alex@example.com", "status": "active" }
  },
  {
    "model": "core.unit",
    "pk": 2,
    "fields": { "condo": 1, "unit_number": "1001", "owner_name": "Blair Owner", "owner_email": "blair@example.com", "status": "active" }
  },
  {
    "model": "core.parkingspot",
    "pk": 1,
    "fields": { "condo": 1, "code": "P1-001", "level": "P1", "spot_type": "owned" }
  },
  {
    "model": "core.parkingspot",
    "pk": 2,
    "fields": { "condo": 1, "code": "P1-002", "level": "P1", "spot_type": "owned" }
  },
  {
    "model": "core.unitparkingassignment",
    "pk": 1,
    "fields": {
      "unit": 1,
      "parking_spot": 1,
      "start_date": "2025-01-01",
      "end_date": null,
      "is_primary": true
    }
  },
  {
    "model": "core.unitparkingassignment",
    "pk": 2,
    "fields": {
      "unit": 2,
      "parking_spot": 2,
      "start_date": "2025-01-01",
      "end_date": null,
      "is_primary": true
    }
  },
  {
    "model": "core.shorttermbooking",
    "pk": 1,
    "fields": {
      "unit": 1,
      "parking_spot": 1,
      "guest_first_name": "Casey",
      "guest_last_name": "Guest",
      "id_type": "DL",
      "id_number": "A1234567",
      "vehicle_plate": "ABCX123",
      "check_in": "2025-09-16T10:00:00Z",
      "check_out": "2025-09-16T14:00:00Z",
      "notes": "fixture booking"
    }
  }
]

================================================================================
FILE: manage.py
================================================================================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "condo_backend.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()

================================================================================
FILE: requirements.txt
================================================================================
Django==5.2.6
djangorestframework==3.16.1
gunicorn==22.0.0
python-dotenv==1.0.1
django-cors-headers==4.8.0
djangorestframework-simplejwt==5.3.1
django-filter==24.3
flake8
drf-spectacular
drf-spectacular-sidecar
