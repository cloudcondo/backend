PROJECT EXPORT (plain text)
Root: /workspaces/backend
Generated: 2025-09-18 19:17:54 UTC
Files included: 77
Max bytes per file: 200000
include_sensitive: False
include_binaries: False
autocommit: False
git_include_ignored: False
WARNING: If include_sensitive=True, secrets like .env are included in this export.
================================================================================

================================================================================
FILE: .devcontainer/devcontainer.json
================================================================================
{
  "name": "Condo SaaS Dev",
  "image": "mcr.microsoft.com/devcontainers/python:3.12",
  "postCreateCommand": "sudo apt-get update && sudo apt-get install -y postgresql-client && pip install --upgrade pip && pip install django djangorestframework psycopg2-binary gunicorn",
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-python.python",
        "esbenp.prettier-vscode"
      ]
    }
  }
}

================================================================================
FILE: .dockerignore
================================================================================
__pycache__/
*.pyc
*.pyo
*.pyd
*.sqlite3
.env
.git
.gitignore
.github/
.vscode/
**/__pycache__/
.media/
staticfiles/

================================================================================
FILE: .env.ci
================================================================================
DEBUG=True
SECRET_KEY=dev-secret-only
ALLOWED_HOSTS=*
CSRF_TRUSTED_ORIGINS=https://bug-free-sniffle-g4wjp5v9g45j2v7pw-8000.app.github.dev,https://localhost:8000,http://localhost:8000

================================================================================
FILE: .env.example
================================================================================
# Copy to .env and fill in for local/dev/prod as needed
DEBUG=True
SECRET_KEY=fill-me
ALLOWED_HOSTS=*
CSRF_TRUSTED_ORIGINS=https://your-app.example.com,https://admin.your-app.example.com

# When moving to Postgres:
# DB_ENGINE=postgres
# DB_NAME=app
# DB_USER=app
# DB_PASSWORD=supersecret
# DB_HOST=your-rds-endpoint
# DB_PORT=5432

================================================================================
FILE: .flake8
================================================================================
[flake8]
max-line-length = 88
extend-ignore = E203, W503, E501, F401
per-file-ignores =
    */migrations/*: E501,F401
    __init__.py: F401

================================================================================
FILE: .github/workflows/ci.yml
================================================================================
name: CI (build, test, push image)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    name: Django tests (SQLite)
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version: [ "3.12", "3.13" ]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            pip-${{ runner.os }}-${{ matrix.python-version }}-

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Django checks, migrate, seed, schema
        env:
          DJANGO_SETTINGS_MODULE: condo_backend.settings
          SECRET_KEY: ci-only-secret-key-change-me
          DEBUG: "True"
          ALLOWED_HOSTS: "*"
        run: |
          python manage.py check
          python manage.py makemigrations --check --dry-run
          python manage.py migrate --noinput
          python manage.py load_sample_data || true
          python manage.py spectacular --file schema.yaml

      - name: CI dry-run CSV import (smoke)
        env:
          DJANGO_SETTINGS_MODULE: condo_backend.settings
        run: |
          python manage.py ci_dry_run_import_check

      - name: Run test suite
        env:
          DJANGO_SETTINGS_MODULE: condo_backend.settings
        run: |
          python manage.py test --verbosity 2

      - name: Upload schema artifact
        uses: actions/upload-artifact@v4
        with:
          name: openapi-schema
          path: schema.yaml

  build-and-push:
    name: Build and push Docker image to GHCR
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha
            type=ref,event=branch

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

================================================================================
FILE: .gitignore
================================================================================
# Python
__pycache__/
*.pyc
*.pyo
*.pyd
*.sqlite3
db.sqlite3

# Envs
.venv/
env/
venv/

# Django
staticfiles/
media/

# VS Code / Codespaces
.vscode/
.python-version

# Byte-compiled
*.egg-info/
dist/
build/

# dotenv
.env

================================================================================
FILE: .isort.cfg
================================================================================
[settings]
profile = black
line_length = 88
combine_as_imports = true
include_trailing_comma = true

================================================================================
FILE: .pre-commit-config.yaml
================================================================================
repos:
  - repo: https://github.com/psf/black
    rev: 24.8.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
  - repo: https://github.com/pycqa/flake8
    rev: 7.1.1
    hooks:
      - id: flake8

================================================================================
FILE: Dockerfile
================================================================================
# Python base
FROM python:3.12-slim

# Prevent Python from buffering stdout/stderr
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1

# OS packages (add build deps only if needed later)
RUN apt-get update && apt-get install -y --no-install-recommends \
    libpq5 curl && \
    rm -rf /var/lib/apt/lists/*

# Workdir
WORKDIR /app

# Install Python deps first (better Docker layer caching)
COPY requirements.txt /app/
RUN pip install --upgrade pip && pip install -r requirements.txt

# Copy project
COPY . /app/

# Runtime env (safe defaults; we’ll override in ECS later)
ENV DJANGO_SETTINGS_MODULE=condo_backend.settings \
    PORT=8000

# Expose port for container platforms
EXPOSE 8000

# Start Gunicorn (Django’s WSGI server)
CMD ["gunicorn", "condo_backend.wsgi:application", "--bind", "0.0.0.0:8000", "--workers", "3", "--timeout", "120"]

================================================================================
FILE: Makefile
================================================================================
VENV=.venv
PY=$(VENV)/bin/python
PIP=$(VENV)/bin/pip

.PHONY: init check makemigrations migrate seed roundtrip test resetdb lint shell run docs schema superuser

init:
	python3 -m venv $(VENV)
	$(PIP) install --upgrade pip
	$(PIP) install -r requirements.txt

check:
	$(PY) manage.py check

makemigrations:
	$(PY) manage.py makemigrations

migrate:
	$(PY) manage.py migrate

seed:
	$(PY) manage.py load_sample_data

roundtrip:
	$(PY) manage.py check_csv_roundtrip

test:
	$(PY) manage.py test -q

resetdb:
	$(PY) manage.py flush --no-input && $(PY) manage.py migrate

lint:
	$(VENV)/bin/flake8 accounts core

shell:
	$(PY) manage.py shell

run:
	$(PY) manage.py runserver 0.0.0.0:8000

# OpenAPI helpers
schema:
	$(PY) manage.py spectacular --file openapi.yaml

docs:
	@echo "Docs live at http://localhost:8000/api/docs/ (Swagger) and /api/redoc/"

superuser:
	$(PY) manage.py createsuperuser

================================================================================
FILE: README.md
================================================================================
# Condo Backend

A Django/DRF service for condo parking assignments and guest bookings.

## Quick start (dev / Codespaces)

```bash
python -m venv .venv && source .venv/bin/activate
pip install -r requirements.txt
python manage.py migrate
python manage.py runserver 0.0.0.0:8000

================================================================================
FILE: accounts/__init__.py
================================================================================
default_app_config = "accounts.apps.AccountsConfig"

================================================================================
FILE: accounts/admin.py
================================================================================
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as DjangoUserAdmin
from django.contrib.auth.models import User

from .models import UnitAccess, UserProfile


@admin.register(UserProfile)
class UserProfileAdmin(admin.ModelAdmin):
    list_display = ("user", "role", "condo", "created_at", "updated_at")
    list_filter = ("role", "condo")
    search_fields = ("user__username", "user__email", "phone")


class UnitAccessInline(admin.TabularInline):
    model = UnitAccess
    extra = 0
    autocomplete_fields = ("unit",)
    fields = ("unit", "access_type", "active", "created_at")
    readonly_fields = ("created_at",)


class UserAdmin(DjangoUserAdmin):
    inlines = [UnitAccessInline]


# Re-register User with inline
admin.site.unregister(User)
admin.site.register(User, UserAdmin)


@admin.register(UnitAccess)
class UnitAccessAdmin(admin.ModelAdmin):
    list_display = ("user", "unit", "access_type", "active", "created_at", "updated_at")
    list_filter = ("access_type", "active", "unit__condo")
    search_fields = ("user__username", "user__email", "unit__unit_number")
    autocomplete_fields = ("user", "unit")

================================================================================
FILE: accounts/apps.py
================================================================================
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = "django.db.models.AutoField"
    name = "accounts"
    verbose_name = "Accounts"

    def ready(self):
        # import signals so post_save hooks register
        from . import signals  # noqa: F401

================================================================================
FILE: accounts/management/commands/seed_demo.py
================================================================================
# accounts/management/commands/seed_demo.py
from django.contrib.auth import get_user_model
from django.core.management.base import BaseCommand
from django.db import transaction

from accounts.models import UnitAccess, UserProfile
from core.models import (
    Condo,
    ParkingSpot,
    ShortTermBooking,
    Unit,
    UnitParkingAssignment,
)


class Command(BaseCommand):
    help = "Seeds demo data: users with roles, units, parking, unit access, and a sample booking"

    @transaction.atomic
    def handle(self, *args, **options):
        U = get_user_model()

        # --- Users ---
        users = {
            "pm": {"username": "pm", "email": "pm@example.com", "password": "changeme"},
            "con": {
                "username": "con",
                "email": "con@example.com",
                "password": "changeme",
            },
            "agent": {
                "username": "agent",
                "email": "agent@example.com",
                "password": "changeme",
            },
            "owner": {
                "username": "owner",
                "email": "owner@example.com",
                "password": "changeme",
            },
        }
        created_users = {}
        for role_key, payload in users.items():
            user, created = U.objects.get_or_create(
                username=payload["username"], defaults={"email": payload["email"]}
            )
            if created:
                user.set_password(payload["password"])
                user.is_staff = role_key == "pm" or role_key == "con"
                user.is_superuser = False
                user.save()
            profile, _ = UserProfile.objects.get_or_create(user=user)
            profile.role = role_key  # 'pm', 'con', 'agent', 'own'
            if role_key == "owner":
                profile.role = "own"
            profile.save()
            created_users[role_key] = user

        # --- Condos / Units / Parking ---
        condo, _ = Condo.objects.get_or_create(
            code="CC01",
            defaults={"name": "Cloud Condo One", "city": "Toronto", "province": "ON"},
        )
        unit101, _ = Unit.objects.get_or_create(
            condo=condo,
            unit_number="101",
            defaults={
                "owner_name": "Alice Owner",
                "owner_email": "alice@example.com",
                "status": "active",
            },
        )
        unit102, _ = Unit.objects.get_or_create(
            condo=condo,
            unit_number="102",
            defaults={
                "owner_name": "Bob Owner",
                "owner_email": "bob@example.com",
                "status": "active",
            },
        )

        spotA1, _ = ParkingSpot.objects.get_or_create(
            condo=condo, code="A1", defaults={"level": "P1", "spot_type": "visitor"}
        )
        spotA2, _ = ParkingSpot.objects.get_or_create(
            condo=condo, code="A2", defaults={"level": "P1", "spot_type": "standard"}
        )

        UnitParkingAssignment.objects.get_or_create(
            unit=unit101, parking_spot=spotA2, defaults={"is_primary": True}
        )

        # --- UnitAccess (agent + owner can access unit 101) ---
        UnitAccess.objects.get_or_create(user=created_users["agent"], unit=unit101)
        UnitAccess.objects.get_or_create(user=created_users["owner"], unit=unit101)

        # --- Sample booking (pending) ---
        ShortTermBooking.objects.get_or_create(
            unit=unit101,
            parking_spot=spotA1,
            guest_first_name="Guest",
            guest_last_name="Example",
            defaults={
                "id_type": "passport",
                "id_number": "X1234567",
                "id_country": "CA",
                "vehicle_plate": "TEST-123",
                "check_in": "2025-09-20",
                "check_out": "2025-09-22",
                "status": "pending",
            },
        )

        self.stdout.write(self.style.SUCCESS("✅ Seeded demo data."))
        self.stdout.write(self.style.SUCCESS("Users (password for all = 'changeme'):"))
        self.stdout.write("  - pm      (Property Manager, staff)")
        self.stdout.write("  - con     (Concierge, staff)")
        self.stdout.write("  - agent   (3rd-party rental manager)")
        self.stdout.write("  - owner   (Unit owner)")

================================================================================
FILE: accounts/migrations/0001_initial.py
================================================================================
import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    # Make sure core tables exist first (Unit/Condo)
    dependencies = [
        (
            "core",
            "0006_remove_parkingspot_notes_db",
        ),  # safe, already applied in your project
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="UserProfile",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "role",
                    models.CharField(
                        choices=[
                            ("pm", "Property Manager"),
                            ("concierge", "Concierge"),
                            ("owner", "Owner"),
                            ("guest", "Guest"),
                            ("partner", "Rental Manager / Partner"),
                        ],
                        default="guest",
                        max_length=20,
                    ),
                ),
                ("phone", models.CharField(blank=True, default="", max_length=50)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "condo",
                    models.ForeignKey(
                        blank=True,
                        help_text="Primary condo this user is associated with (optional).",
                        null=True,
                        on_delete=django.db.models.deletion.SET_NULL,
                        to="core.condo",
                    ),
                ),
                (
                    "user",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="profile",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
            options={
                "verbose_name": "User Profile",
                "verbose_name_plural": "User Profiles",
                "db_table": "accounts_userprofile",
            },
        ),
        migrations.CreateModel(
            name="UnitAccess",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "access_type",
                    models.CharField(
                        choices=[
                            ("owner", "Owner"),
                            ("rental_manager", "Rental Manager"),
                            ("tenant", "Tenant"),
                            ("guest_submitter", "Guest Submitter"),
                        ],
                        default="owner",
                        max_length=20,
                    ),
                ),
                ("active", models.BooleanField(default=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "unit",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="accesses",
                        to="core.unit",
                    ),
                ),
                (
                    "user",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="unit_accesses",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
            options={
                "verbose_name": "Unit Access",
                "verbose_name_plural": "Unit Access",
                "db_table": "accounts_unitaccess",
                "unique_together": {("user", "unit", "access_type")},
            },
        ),
    ]

================================================================================
FILE: accounts/migrations/__init__.py
================================================================================


================================================================================
FILE: accounts/models.py
================================================================================
from django.conf import settings
from django.db import models

User = settings.AUTH_USER_MODEL


class Role:
    """Lightweight enum-like constants used in views/permissions."""

    PROPERTY_MANAGER = "pm"
    CONCIERGE = "concierge"
    OWNER = "owner"
    GUEST = "guest"
    PARTNER = "partner"  # Rental manager / 3rd-party agent

    CHOICES = [
        (PROPERTY_MANAGER, "Property Manager"),
        (CONCIERGE, "Concierge"),
        (OWNER, "Owner"),
        (GUEST, "Guest"),
        (PARTNER, "Rental Manager / Partner"),
    ]


class AccessType:
    OWNER = "owner"
    RENTAL_MANAGER = "rental_manager"
    TENANT = "tenant"
    GUEST_SUBMITTER = "guest_submitter"

    CHOICES = [
        (OWNER, "Owner"),
        (RENTAL_MANAGER, "Rental Manager"),
        (TENANT, "Tenant"),
        (GUEST_SUBMITTER, "Guest Submitter"),
    ]


class UserProfile(models.Model):
    """
    Per-user role (highest/global role) and optional condo affinity.
    Use UnitAccess for per-unit permissions.
    """

    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")
    role = models.CharField(max_length=20, choices=Role.CHOICES, default=Role.GUEST)
    condo = models.ForeignKey(
        "core.Condo",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        help_text="Primary condo this user is associated with (optional).",
    )
    phone = models.CharField(max_length=50, blank=True, default="")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = "accounts_userprofile"
        verbose_name = "User Profile"
        verbose_name_plural = "User Profiles"

    def __str__(self) -> str:
        return f"{self.user} · {self.get_role_display()}"


class UnitAccess(models.Model):
    """
    Grants a user access/authority for a specific Unit.
    Useful when the owner uses a third-party rental manager to submit guests.
    """

    user = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="unit_accesses"
    )
    unit = models.ForeignKey(
        "core.Unit", on_delete=models.CASCADE, related_name="accesses"
    )
    access_type = models.CharField(
        max_length=20, choices=AccessType.CHOICES, default=AccessType.OWNER
    )
    active = models.BooleanField(default=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = "accounts_unitaccess"
        unique_together = [("user", "unit", "access_type")]
        verbose_name = "Unit Access"
        verbose_name_plural = "Unit Access"

    def __str__(self) -> str:
        return f"{self.user} ↔ {self.unit} ({self.get_access_type_display()})"

================================================================================
FILE: accounts/permissions.py
================================================================================
# accounts/permissions.py
from rest_framework.permissions import SAFE_METHODS, BasePermission


def _role(user):
    return getattr(getattr(user, "profile", None), "role", None)


class IsAuthenticatedJWT(BasePermission):
    """
    Works with DRF SimpleJWT. If JWT auth is configured in REST_FRAMEWORK,
    request.user will be authenticated when a valid token is provided.
    """

    def has_permission(self, request, view):
        return bool(getattr(request, "user", None) and request.user.is_authenticated)


class ReadOnly(BasePermission):
    def has_permission(self, request, view):
        return request.method in SAFE_METHODS


class IsPropertyManager(BasePermission):
    def has_permission(self, request, view):
        return _role(request.user) == "pm"


class IsConcierge(BasePermission):
    def has_permission(self, request, view):
        return _role(request.user) == "con"


class IsAgent(BasePermission):
    """Third-party rental manager."""

    def has_permission(self, request, view):
        return _role(request.user) == "agent"


class IsOwner(BasePermission):
    def has_permission(self, request, view):
        return _role(request.user) == "own"

================================================================================
FILE: accounts/serializers.py
================================================================================
# accounts/serializers.py
from django.contrib.auth import get_user_model
from rest_framework import serializers

from .models import Role, UnitAccess, UserProfile

User = get_user_model()


class UserProfileSerializer(serializers.ModelSerializer):
    username = serializers.CharField(source="user.username", read_only=True)
    email = serializers.EmailField(source="user.email", read_only=True)

    class Meta:
        model = UserProfile
        fields = ["username", "email", "role"]


class UnitAccessSerializer(serializers.ModelSerializer):
    user = serializers.PrimaryKeyRelatedField(queryset=User.objects.all())
    unit = serializers.PrimaryKeyRelatedField(read_only=False)

    class Meta:
        model = UnitAccess
        fields = ["id", "user", "unit", "access_type", "created_at"]
        read_only_fields = ["id", "created_at"]

================================================================================
FILE: accounts/signals.py
================================================================================
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver

from .models import UserProfile

User = settings.AUTH_USER_MODEL


@receiver(post_save, sender=User)
def create_profile_for_new_user(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.get_or_create(user=instance)

================================================================================
FILE: assignments.csv
================================================================================
condo_code,unit_number,parking_code,status,effective_start,effective_end
TSCC1848,1001,P1-002,active,2025-01-01,
TSCC1848,905,P1-001,active,2025-01-01,

================================================================================
FILE: ci_touch.txt
================================================================================
# trigger CI again

================================================================================
FILE: condo_backend/__init__.py
================================================================================


================================================================================
FILE: condo_backend/asgi.py
================================================================================
"""
ASGI config for condo_backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "condo_backend.settings")

application = get_asgi_application()

================================================================================
FILE: condo_backend/settings.py
================================================================================
"""
Django settings for condo_backend project.
"""

import os
from datetime import timedelta
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

# .env support (optional)
DOTENV_PATH = BASE_DIR / ".env"
if DOTENV_PATH.exists():
    try:
        from dotenv import load_dotenv

        load_dotenv(DOTENV_PATH)
    except Exception:
        pass

DEBUG = os.getenv("DEBUG", "True") == "True"
SECRET_KEY = os.getenv("SECRET_KEY", "dev-only-not-secure")
ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "*").split(",")
CSRF_TRUSTED_ORIGINS = (
    os.getenv("CSRF_TRUSTED_ORIGINS", "").split(",")
    if os.getenv("CSRF_TRUSTED_ORIGINS")
    else []
)

INSTALLED_APPS = [
    # Django
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # Third-party
    "rest_framework",
    "corsheaders",
    "django_filters",
    "drf_spectacular",
    # Local
    "accounts",
    "core",
    # Scheduled jobs
    "django_crontab",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    # lightweight write audit
    "core.middleware_audit.AuditWriteMiddleware",
]

ROOT_URLCONF = "condo_backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "condo_backend.wsgi.application"

# Database
if os.getenv("DB_ENGINE") == "postgres":
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.postgresql",
            "NAME": os.getenv("DB_NAME", "app"),
            "USER": os.getenv("DB_USER", "app"),
            "PASSWORD": os.getenv("DB_PASSWORD", ""),
            "HOST": os.getenv("DB_HOST", "localhost"),
            "PORT": os.getenv("DB_PORT", "5432"),
        }
    }
else:
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"
    },
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

LANGUAGE_CODE = "en-us"
TIME_ZONE = "UTC"
USE_I18N = True
USE_TZ = True

STATIC_URL = "static/"
STATIC_ROOT = BASE_DIR / "staticfiles"

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ),
    "DEFAULT_PERMISSION_CLASSES": ("rest_framework.permissions.IsAuthenticated",),
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
    "DEFAULT_FILTER_BACKENDS": [
        "django_filters.rest_framework.DjangoFilterBackend",
    ],
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
    # throttling for login/writes (global rates)
    "DEFAULT_THROTTLE_CLASSES": [
        "rest_framework.throttling.UserRateThrottle",
        "rest_framework.throttling.AnonRateThrottle",
    ],
    "DEFAULT_THROTTLE_RATES": {
        "user": "200/min",
        "anon": "50/min",
    },
}

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=30),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
}

SPECTACULAR_SETTINGS = {
    "TITLE": "Condo Backend API",
    "DESCRIPTION": "Parking assignments, short-term bookings, and RBAC.",
    "VERSION": "1.0.0",
    "SERVERS": [{"url": "http://localhost:8000"}],
    # If you use drf-spectacular-sidecar, you can set SIDECAR assets here.
    # Otherwise the defaults are fine.
}

# CORS / CSRF
if DEBUG:
    CORS_ALLOW_ALL_ORIGINS = True
else:
    CORS_ALLOW_ALL_ORIGINS = False
    CORS_ALLOWED_ORIGINS = (
        os.getenv("CORS_ALLOWED_ORIGINS", "").split(",")
        if os.getenv("CORS_ALLOWED_ORIGINS")
        else []
    )
CORS_ALLOW_CREDENTIALS = True

SECURE_BROWSER_XSS_FILTER = True
SESSION_COOKIE_SECURE = False if DEBUG else True
CSRF_COOKIE_SECURE = False if DEBUG else True

# nightly CSV export + retention
ASSIGNMENTS_EXPORT_RETENTION_DAYS = int(
    os.getenv("ASSIGNMENTS_EXPORT_RETENTION_DAYS", "14")
)
ASSIGNMENTS_EXPORT_DIR = os.getenv("ASSIGNMENTS_EXPORT_DIR", str(BASE_DIR / "exports"))

# django-crontab: run at 02:15 UTC daily and hourly reminders
CRONJOBS = [
    ("15 2 * * *", "core.cron.nightly_export_and_cleanup"),
    ("0 * * * *", "core.cron.email_reminders_checkins_outs"),
]

================================================================================
FILE: condo_backend/urls.py
================================================================================
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.http import HttpResponse, JsonResponse
from django.urls import include, path

# API schema / docs
from drf_spectacular.views import (
    SpectacularAPIView,
    SpectacularRedocView,
    SpectacularSwaggerView,
)

# JWT auth
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView


def home(_request):
    return HttpResponse("Condo backend is running")


def ping(_request):
    return JsonResponse({"pong": True})


def health(_request):
    return JsonResponse({"ok": True})


urlpatterns = [
    path("", home),
    path("api/healthz", health),
    path("api/ping", ping),
    # Core API (viewsets + CSV + reports)
    path("api/", include("core.urls")),
    # Auth (JWT)
    path("api/auth/token/", TokenObtainPairView.as_view(), name="token_obtain_pair"),
    path("api/auth/token/refresh/", TokenRefreshView.as_view(), name="token_refresh"),
    # OpenAPI / Docs
    path("api/schema/", SpectacularAPIView.as_view(), name="schema"),
    path(
        "api/docs/",
        SpectacularSwaggerView.as_view(url_name="schema"),
        name="swagger-ui",
    ),
    path("api/redoc/", SpectacularRedocView.as_view(url_name="schema"), name="redoc"),
    path("admin/", admin.site.urls),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


def api_error(request, *args, **kwargs):
    return JsonResponse(
        {
            "error": {
                "code": "not_found",
                "detail": "The requested resource was not found.",
            }
        },
        status=404,
    )


handler404 = "condo_backend.urls.api_error"

================================================================================
FILE: condo_backend/wsgi.py
================================================================================
"""
WSGI config for condo_backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "condo_backend.settings")

application = get_wsgi_application()

================================================================================
FILE: core/__init__.py
================================================================================


================================================================================
FILE: core/admin.py
================================================================================
from django.contrib import admin
from django.utils import timezone

from .models import Condo, ParkingSpot, ShortTermBooking, Unit, UnitParkingAssignment


@admin.register(Condo)
class CondoAdmin(admin.ModelAdmin):
    list_display = ("id", "code", "name")
    search_fields = ("code", "name")


@admin.register(Unit)
class UnitAdmin(admin.ModelAdmin):
    list_display = ("id", "unit_number", "condo")
    list_filter = ("condo",)
    search_fields = ("unit_number",)
    autocomplete_fields = ("condo",)


@admin.register(ParkingSpot)
class ParkingSpotAdmin(admin.ModelAdmin):
    list_display = ("id", "code", "condo", "level", "spot_type")
    list_filter = ("condo", "spot_type", "level")
    search_fields = ("code",)
    autocomplete_fields = ("condo",)


@admin.action(description="Approve selected bookings")
def approve_bookings(modeladmin, request, queryset):
    queryset.update(
        status="approved", reviewed_by=request.user, reviewed_at=timezone.now()
    )


@admin.action(description="Reject selected bookings")
def reject_bookings(modeladmin, request, queryset):
    queryset.update(
        status="rejected", reviewed_by=request.user, reviewed_at=timezone.now()
    )


@admin.register(UnitParkingAssignment)
class UnitParkingAssignmentAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "unit",
        "parking_spot",
        "start_date",
        "end_date",
        "is_primary",
    )
    list_filter = ("unit__condo", "is_primary")
    search_fields = ("unit__unit_number", "parking_spot__code")
    autocomplete_fields = ("unit", "parking_spot")


@admin.register(ShortTermBooking)
class ShortTermBookingAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "unit",
        "parking_spot",
        "guest_first_name",
        "guest_last_name",
        "check_in",
        "check_out",
        "status",
    )
    list_filter = ("unit__condo", "status")
    search_fields = (
        "guest_first_name",
        "guest_last_name",
        "vehicle_plate",
        "unit__unit_number",
        "parking_spot__code",
    )
    autocomplete_fields = ("unit", "parking_spot")
    actions = [approve_bookings, reject_bookings]

================================================================================
FILE: core/apps.py
================================================================================
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"

================================================================================
FILE: core/cron.py
================================================================================
# core/cron.py
import os
from datetime import datetime, timedelta
from pathlib import Path

from django.conf import settings
from django.core.mail import send_mail
from django.utils import timezone

from .models import ShortTermBooking
from .services.csv_roundtrip import export_assignments_csv_text  # defined below


def nightly_export_and_cleanup():
    base = Path(getattr(settings, "ASSIGNMENTS_EXPORT_DIR", "exports"))
    base.mkdir(parents=True, exist_ok=True)
    ts = datetime.utcnow().strftime("%Y%m%d")
    out = base / f"assignments_{ts}.csv"
    out.write_text(export_assignments_csv_text(), encoding="utf-8")

    # retention
    keep_days = int(getattr(settings, "ASSIGNMENTS_EXPORT_RETENTION_DAYS", 14))
    cutoff = timezone.now() - timedelta(days=keep_days)
    for p in base.glob("assignments_*.csv"):
        # naive parse: assignments_YYYYMMDD.csv
        try:
            d = datetime.strptime(p.stem.split("_")[1], "%Y%m%d")
            if d < cutoff.replace(tzinfo=None):
                p.unlink(missing_ok=True)
        except Exception:
            continue


def email_reminders_checkins_outs():
    today = timezone.localdate()
    soon = today + timedelta(days=1)
    qs_in = ShortTermBooking.objects.filter(check_in=today, status="approved")
    qs_out = ShortTermBooking.objects.filter(check_out=soon, status="approved")
    # This is a stub. Replace send_mail with your email backend/config.
    for b in qs_in:
        send_mail(
            subject=f"Reminder: Guest checking in today for {b.unit}",
            message=f"Guest {b.guest_first_name} {b.guest_last_name} — plate {b.vehicle_plate or 'n/a'}",
            from_email=os.getenv("DEFAULT_FROM_EMAIL", "noreply@example.com"),
            recipient_list=[os.getenv("REMINDER_TO_EMAIL", "ops@example.com")],
            fail_silently=True,
        )
    for b in qs_out:
        send_mail(
            subject=f"Reminder: Guest checks out tomorrow for {b.unit}",
            message=f"Booking {b.id} ends {b.check_out.isoformat()}",
            from_email=os.getenv("DEFAULT_FROM_EMAIL", "noreply@example.com"),
            recipient_list=[os.getenv("REMINDER_TO_EMAIL", "ops@example.com")],
            fail_silently=True,
        )

================================================================================
FILE: core/filters.py
================================================================================
# core/filters.py
import django_filters

from .models import ShortTermBooking


class ShortTermBookingFilter(django_filters.FilterSet):
    check_in_after = django_filters.DateFilter(field_name="check_in", lookup_expr="gte")
    check_in_before = django_filters.DateFilter(
        field_name="check_in", lookup_expr="lte"
    )
    check_out_after = django_filters.DateFilter(
        field_name="check_out", lookup_expr="gte"
    )
    check_out_before = django_filters.DateFilter(
        field_name="check_out", lookup_expr="lte"
    )

    class Meta:
        model = ShortTermBooking
        fields = [
            "unit",
            "parking_spot",
            "status",
            "check_in_after",
            "check_in_before",
            "check_out_after",
            "check_out_before",
        ]

================================================================================
FILE: core/fixtures/sample_data.json
================================================================================
[
  {
    "model": "core.condo",
    "pk": 1,
    "fields": {
      "code": "TSCC1848",
      "name": "TSCC 1848",
      "city": "Toronto",
      "province": "ON",
      "created_at": "2025-01-01T00:00:00Z",
      "updated_at": "2025-01-01T00:00:00Z"
    }
  },
  {
    "model": "core.unit",
    "pk": 1,
    "fields": {
      "condo": 1,
      "unit_number": "905",
      "owner_name": "Alex Owner",
      "owner_email": "alex@example.com",
      "status": "OWNER_OCCUPIED",
      "created_at": "2025-01-01T00:05:00Z",
      "updated_at": "2025-01-01T00:05:00Z"
    }
  },
  {
    "model": "core.unit",
    "pk": 2,
    "fields": {
      "condo": 1,
      "unit_number": "1001",
      "owner_name": "Blair Owner",
      "owner_email": "blair@example.com",
      "status": "OWNER_OCCUPIED",
      "created_at": "2025-01-01T00:06:00Z",
      "updated_at": "2025-01-01T00:06:00Z"
    }
  },
  {
    "model": "core.parkingspot",
    "pk": 1,
    "fields": {
      "condo": 1,
      "code": "P1-001",
      "level": "P1",
      "spot_type": "RESIDENT",
      "created_at": "2025-01-01T00:10:00Z",
      "updated_at": "2025-01-01T00:10:00Z"
    }
  },
  {
    "model": "core.parkingspot",
    "pk": 2,
    "fields": {
      "condo": 1,
      "code": "P1-002",
      "level": "P1",
      "spot_type": "RESIDENT",
      "created_at": "2025-01-01T00:11:00Z",
      "updated_at": "2025-01-01T00:11:00Z"
    }
  },
  {
    "model": "core.unitparkingassignment",
    "pk": 1,
    "fields": {
      "unit": 1,
      "parking_spot": 1,
      "start_date": "2025-01-01",
      "end_date": null,
      "is_primary": true,
      "created_at": "2025-01-01T00:15:00Z",
      "updated_at": "2025-01-01T00:15:00Z"
    }
  },
  {
    "model": "core.unitparkingassignment",
    "pk": 2,
    "fields": {
      "unit": 2,
      "parking_spot": 2,
      "start_date": "2025-01-01",
      "end_date": null,
      "is_primary": true,
      "created_at": "2025-01-01T00:16:00Z",
      "updated_at": "2025-01-01T00:16:00Z"
    }
  },
  {
    "model": "core.shorttermbooking",
    "pk": 1,
    "fields": {
      "unit": 1,
      "parking_spot": 1,
      "guest_first_name": "Casey",
      "guest_last_name": "Guest",
      "id_type": "LICENSE",
      "id_number": "A1234567",
      "id_country": "CA",
      "id_province_state": "ON",
      "vehicle_plate": "ABCX123",
      "check_in": "2025-09-16",
      "check_out": "2025-09-16",
      "status": "pending",
      "notes": "fixture booking",
      "created_at": "2025-01-01T00:20:00Z",
      "updated_at": "2025-01-01T00:20:00Z"
    }
  }
]

================================================================================
FILE: core/management/commands/check_csv_roundtrip.py
================================================================================
from django.core.management.base import BaseCommand
from django.utils import timezone

from core.models import UnitParkingAssignment


class Command(BaseCommand):
    help = "Sanity check: every active assignment links a unit to a parking spot and vice versa"

    def handle(self, *args, **kwargs):
        missing = []
        for a in UnitParkingAssignment.objects.select_related("unit", "parking_spot"):
            if not a.unit_id or not a.parking_spot_id:
                missing.append(a.pk)
        if missing:
            self.stderr.write(f"Incomplete assignments (no unit or no spot): {missing}")
            raise SystemExit(1)
        self.stdout.write(self.style.SUCCESS("Assignment round-trip looks good."))

================================================================================
FILE: core/management/commands/ci_dry_run_import_check.py
================================================================================
# core/management/commands/ci_dry_run_import_check.py
import csv
from io import BytesIO

from django.contrib.auth import get_user_model
from django.core.management.base import BaseCommand, CommandError
from rest_framework.test import APIClient

from accounts.models import UserProfile
from core.models import Condo, ParkingSpot, Unit


class Command(BaseCommand):
    help = "CI smoke: POST /api/assignments/import.csv?dry_run=1 and assert counts in JSON response."

    def handle(self, *args, **opts):
        # Make sure we have at least one condo/unit/spot (fixtures/seeded in CI)
        condo = Condo.objects.first()
        unit = Unit.objects.filter(condo=condo).first() if condo else None
        spot = ParkingSpot.objects.filter(condo=condo).first() if condo else None
        if not (condo and unit and spot):
            raise CommandError(
                "Missing seeded data (condo/unit/spot). Load fixtures first."
            )

        # Build minimal CSV in memory
        mem = BytesIO()
        writer = csv.writer(mem)
        writer.writerow(
            [
                "condo_code",
                "unit_number",
                "parking_code",
                "status",
                "effective_start",
                "effective_end",
            ]
        )
        writer.writerow([condo.code, unit.unit_number, spot.code, "active", "", ""])
        mem.seek(0)
        mem.name = "assignments.csv"  # DRF uses .name to infer filename

        # Create a PM user (so endpoint is authorized)
        U = get_user_model()
        pm, _ = U.objects.get_or_create(
            username="ci-pm", defaults={"email": "ci-pm@example.com", "is_staff": True}
        )
        prof, _ = UserProfile.objects.get_or_create(user=pm)
        prof.role = "pm"
        prof.save()

        client = APIClient()
        client.force_authenticate(user=pm)
        resp = client.post(
            "/api/assignments/import.csv?dry_run=1",
            data={"file": mem},
            format="multipart",
        )
        if resp.status_code != 200:
            raise CommandError(
                f"Import endpoint failed: {resp.status_code} {resp.content!r}"
            )

        data = resp.json()
        # We expect at least one processed row and no crash
        if "total_rows" not in data or data["total_rows"] < 1:
            raise CommandError(f"Unexpected response: {data}")
        # Accepted keys present
        for key in ["created", "updated", "errors", "dry_run"]:
            if key not in data:
                raise CommandError(f"Missing key '{key}' in response: {data}")

        self.stdout.write(self.style.SUCCESS("CI dry-run CSV import check passed."))

================================================================================
FILE: core/management/commands/export_assignments_csv.py
================================================================================
from pathlib import Path

from django.core.management.base import BaseCommand

from core.services.csv_assignments import export_all_assignments


class Command(BaseCommand):
    help = "Export Unit↔Parking assignments to CSV."

    def add_arguments(self, parser):
        parser.add_argument(
            "--out", default="exports/assignments.csv", help="Output CSV path"
        )

    def handle(self, *args, **opts):
        out = Path(opts["out"])
        out.parent.mkdir(parents=True, exist_ok=True)
        csv_text = export_all_assignments()
        out.write_text(csv_text, encoding="utf-8")
        self.stdout.write(self.style.SUCCESS(f"Wrote {out} ({len(csv_text)} bytes)"))

================================================================================
FILE: core/management/commands/import_assignments_csv.py
================================================================================
from pathlib import Path

from django.core.management.base import BaseCommand, CommandError

from core.services.csv_assignments import import_assignments_csv


class Command(BaseCommand):
    help = "Import/Upsert Unit↔Parking assignments from CSV."

    def add_arguments(self, parser):
        parser.add_argument("csv_path", help="Path to CSV file")

    def handle(self, *args, **opts):
        p = Path(opts["csv_path"])
        if not p.exists():
            raise CommandError(f"File not found: {p}")
        changed, warnings = import_assignments_csv(p.read_text(encoding="utf-8"))
        for w in warnings:
            self.stderr.write(w)
        self.stdout.write(self.style.SUCCESS(f"Imported/updated rows: {changed}"))

================================================================================
FILE: core/management/commands/load_sample_data.py
================================================================================
from pathlib import Path

from django.apps import apps
from django.core.management import call_command
from django.core.management.base import BaseCommand, CommandError


class Command(BaseCommand):
    help = "Load sample data fixtures for local/CI runs"

    def add_arguments(self, parser):
        parser.add_argument(
            "--flush", action="store_true", help="Flush DB before loading fixtures"
        )

    def handle(self, *args, **opts):
        core_path = Path(apps.get_app_config("core").path)
        fixture_path = core_path / "fixtures" / "sample_data.json"
        if not fixture_path.exists():
            raise CommandError(f"Fixture not found: {fixture_path}")

        if opts["flush"]:
            self.stdout.write("Flushing database...")
            call_command("flush", interactive=False)

        self.stdout.write(f"Loading fixture: {fixture_path}")
        call_command("loaddata", str(fixture_path))
        self.stdout.write(self.style.SUCCESS("Sample data loaded."))

================================================================================
FILE: core/middleware_audit.py
================================================================================
# core/middleware_audit.py
import json
from datetime import datetime

from django.conf import settings
from django.http import HttpRequest
from django.utils.deprecation import MiddlewareMixin


class AuditWriteMiddleware(MiddlewareMixin):
    """
    VERY simple file-based audit for POST/PUT/PATCH/DELETE.
    Writes newline-delimited JSON to MEDIA_ROOT/audit/audit.log
    (Swap to a DB model later if needed.)
    """

    def process_response(self, request: HttpRequest, response):
        if request.method in (
            "POST",
            "PUT",
            "PATCH",
            "DELETE",
        ) and request.path.startswith("/api/"):
            try:
                body = request.body.decode("utf-8")[:4096]
            except Exception:
                body = "<unreadable>"
            line = {
                "ts": datetime.utcnow().isoformat() + "Z",
                "path": request.path,
                "method": request.method,
                "status": response.status_code,
                "user": getattr(getattr(request, "user", None), "username", None),
                "ip": request.META.get("REMOTE_ADDR"),
                "body": body,
            }
            try:
                import os

                base = os.path.join(getattr(settings, "MEDIA_ROOT", "media"), "audit")
                os.makedirs(base, exist_ok=True)
                with open(os.path.join(base, "audit.log"), "a", encoding="utf-8") as f:
                    f.write(json.dumps(line, ensure_ascii=False) + "\n")
            except Exception:
                pass
        return response

================================================================================
FILE: core/migrations/0001_initial.py
================================================================================
# Generated by Django 5.2.6 on 2025-09-09 19:30

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Condo",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("name", models.CharField(max_length=200)),
                ("address", models.CharField(blank=True, max_length=255)),
                ("city", models.CharField(blank=True, max_length=100)),
                ("province", models.CharField(blank=True, max_length=50)),
                ("code", models.CharField(blank=True, max_length=50)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
            ],
            options={
                "ordering": ["name"],
            },
        ),
    ]

================================================================================
FILE: core/migrations/0002_unit.py
================================================================================
# Generated by Django 5.2.6 on 2025-09-09 20:16

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0001_initial"),
    ]

    operations = [
        migrations.CreateModel(
            name="Unit",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("unit_number", models.CharField(max_length=20)),
                ("owner_name", models.CharField(blank=True, max_length=200)),
                ("owner_email", models.EmailField(blank=True, max_length=254)),
                ("status", models.CharField(blank=True, max_length=30)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "condo",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="units",
                        to="core.condo",
                    ),
                ),
            ],
            options={
                "ordering": ["condo__name", "unit_number"],
                "unique_together": {("condo", "unit_number")},
            },
        ),
    ]

================================================================================
FILE: core/migrations/0003_parkingspot_shorttermbooking_unitparkingassignment.py
================================================================================
# Generated by Django 5.2.6 on 2025-09-09 20:29

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0002_unit"),
    ]

    operations = [
        migrations.CreateModel(
            name="ParkingSpot",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("code", models.CharField(max_length=50)),
                ("level", models.CharField(blank=True, max_length=50)),
                ("spot_type", models.CharField(blank=True, max_length=30)),
                ("notes", models.TextField(blank=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "condo",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="parking_spots",
                        to="core.condo",
                    ),
                ),
            ],
            options={
                "ordering": ["condo__name", "code"],
                "unique_together": {("condo", "code")},
            },
        ),
        migrations.CreateModel(
            name="ShortTermBooking",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("guest_first_name", models.CharField(max_length=100)),
                ("guest_last_name", models.CharField(max_length=100)),
                ("guest_email", models.EmailField(blank=True, max_length=254)),
                ("guest_phone", models.CharField(blank=True, max_length=50)),
                (
                    "id_type",
                    models.CharField(
                        choices=[
                            ("DL", "Driver License"),
                            ("PASS", "Passport"),
                            ("NID", "National ID"),
                            ("OTHER", "Other"),
                        ],
                        default="DL",
                        max_length=10,
                    ),
                ),
                ("id_number", models.CharField(max_length=100)),
                ("id_country", models.CharField(blank=True, max_length=100)),
                ("id_province_state", models.CharField(blank=True, max_length=100)),
                ("id_city", models.CharField(blank=True, max_length=100)),
                ("check_in", models.DateTimeField()),
                ("check_out", models.DateTimeField()),
                ("num_guests", models.PositiveIntegerField(default=1)),
                ("vehicle_plate", models.CharField(blank=True, max_length=30)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("approved", "Approved"),
                            ("rejected", "Rejected"),
                            ("cancelled", "Cancelled"),
                            ("completed", "Completed"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
                ("created_by_email", models.EmailField(blank=True, max_length=254)),
                ("approved_by", models.CharField(blank=True, max_length=150)),
                ("approved_at", models.DateTimeField(blank=True, null=True)),
                ("notes", models.TextField(blank=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "parking_spot",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.SET_NULL,
                        to="core.parkingspot",
                    ),
                ),
                (
                    "unit",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="str_bookings",
                        to="core.unit",
                    ),
                ),
            ],
            options={
                "ordering": ["-check_in"],
            },
        ),
        migrations.CreateModel(
            name="UnitParkingAssignment",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("start_date", models.DateField()),
                ("end_date", models.DateField(blank=True, null=True)),
                ("is_primary", models.BooleanField(default=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "parking_spot",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.PROTECT,
                        related_name="assignments",
                        to="core.parkingspot",
                    ),
                ),
                (
                    "unit",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="parking_assignments",
                        to="core.unit",
                    ),
                ),
            ],
            options={
                "ordering": ["unit__condo__name", "unit__unit_number", "-start_date"],
            },
        ),
    ]

================================================================================
FILE: core/migrations/0004_alter_shorttermbooking_dates_to_datefield.py
================================================================================
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0003_parkingspot_shorttermbooking_unitparkingassignment"),
    ]

    operations = [
        migrations.AlterField(
            model_name="shorttermbooking",
            name="check_in",
            field=models.DateField(),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="check_out",
            field=models.DateField(),
        ),
    ]

================================================================================
FILE: core/migrations/0005_safe_cleanup_and_updated_at.py
================================================================================
from django.db import migrations, models
from django.utils import timezone


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0004_alter_shorttermbooking_dates_to_datefield"),
    ]

    operations = [
        # Add updated_at to all models (aligns with your models.py)
        migrations.AddField(
            model_name="condo",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="unit",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="parkingspot",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="unitparkingassignment",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="shorttermbooking",
            name="updated_at",
            field=models.DateTimeField(default=timezone.now, auto_now=True),
            preserve_default=False,
        ),
        # Don’t try to DROP columns in SQLite that never existed.
        # Update Django state only so future migrations stay consistent.
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.RemoveField(model_name="parkingspot", name="notes"),
                migrations.RemoveField(
                    model_name="shorttermbooking", name="approved_at"
                ),
                migrations.RemoveField(
                    model_name="shorttermbooking", name="approved_by"
                ),
                migrations.RemoveField(
                    model_name="shorttermbooking", name="created_by_email"
                ),
                migrations.RemoveField(
                    model_name="shorttermbooking", name="guest_email"
                ),
                migrations.RemoveField(
                    model_name="shorttermbooking", name="guest_phone"
                ),
                migrations.RemoveField(model_name="shorttermbooking", name="id_city"),
                migrations.RemoveField(
                    model_name="shorttermbooking", name="num_guests"
                ),
            ]
        ),
    ]

================================================================================
FILE: core/migrations/0006_remove_parkingspot_notes_db.py
================================================================================
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0005_safe_cleanup_and_updated_at"),
    ]

    operations = [
        # Make Django aware of the field again (state only; no DB change here).
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddField(
                    model_name="parkingspot",
                    name="notes",
                    field=models.TextField(blank=True, null=True, default=""),
                ),
            ],
            database_operations=[],
        ),
        # Now actually drop it (SQLite will recreate the table).
        migrations.RemoveField(
            model_name="parkingspot",
            name="notes",
        ),
    ]

================================================================================
FILE: core/migrations/0007_drop_shorttermbooking_legacy_columns_db.py
================================================================================
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0006_remove_parkingspot_notes_db"),
    ]

    operations = [
        # 1) Re-introduce legacy fields in *state only* so Django "knows" them.
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="approved_at",
                    field=models.DateTimeField(null=True, blank=True, default=None),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="approved_by",
                    field=models.CharField(
                        max_length=255, null=True, blank=True, default=""
                    ),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="created_by_email",
                    field=models.CharField(
                        max_length=255, null=True, blank=True, default=""
                    ),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="guest_email",
                    field=models.CharField(
                        max_length=255, null=True, blank=True, default=""
                    ),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="guest_phone",
                    field=models.CharField(
                        max_length=50, null=True, blank=True, default=""
                    ),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="id_city",
                    field=models.CharField(
                        max_length=255, null=True, blank=True, default=""
                    ),
                ),
                migrations.AddField(
                    model_name="shorttermbooking",
                    name="num_guests",
                    field=models.IntegerField(null=True, blank=True, default=None),
                ),
            ],
            database_operations=[],
        ),
        # 2) Now actually remove them (DB operation). On SQLite this rebuilds the table
        # without these columns, eliminating NOT NULL constraints left behind.
        migrations.RemoveField(model_name="shorttermbooking", name="approved_at"),
        migrations.RemoveField(model_name="shorttermbooking", name="approved_by"),
        migrations.RemoveField(model_name="shorttermbooking", name="created_by_email"),
        migrations.RemoveField(model_name="shorttermbooking", name="guest_email"),
        migrations.RemoveField(model_name="shorttermbooking", name="guest_phone"),
        migrations.RemoveField(model_name="shorttermbooking", name="id_city"),
        migrations.RemoveField(model_name="shorttermbooking", name="num_guests"),
    ]

================================================================================
FILE: core/migrations/0008_booking_workflow_and_file.py
================================================================================
import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):
    # Make 0008 depend on 0007 to linearize the graph.
    dependencies = [
        ("core", "0007_drop_shorttermbooking_legacy_columns_db"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        # Workflow fields
        migrations.AddField(
            model_name="shorttermbooking",
            name="submitted_by",
            field=models.ForeignKey(
                to=settings.AUTH_USER_MODEL,
                on_delete=django.db.models.deletion.SET_NULL,
                null=True,
                blank=True,
                related_name="bookings_submitted",
            ),
        ),
        migrations.AddField(
            model_name="shorttermbooking",
            name="reviewed_by",
            field=models.ForeignKey(
                to=settings.AUTH_USER_MODEL,
                on_delete=django.db.models.deletion.SET_NULL,
                null=True,
                blank=True,
                related_name="bookings_reviewed",
            ),
        ),
        migrations.AddField(
            model_name="shorttermbooking",
            name="reviewed_at",
            field=models.DateTimeField(null=True, blank=True),
        ),
        # Optional ID upload
        migrations.AddField(
            model_name="shorttermbooking",
            name="id_document",
            field=models.FileField(upload_to="ids/", null=True, blank=True),
        ),
        # Normalize statuses (lowercase)
        migrations.AlterField(
            model_name="shorttermbooking",
            name="status",
            field=models.CharField(
                max_length=16,
                choices=[
                    ("pending", "Pending"),
                    ("approved", "Approved"),
                    ("rejected", "Rejected"),
                    ("cancelled", "Cancelled"),
                ],
                default="pending",
            ),
        ),
    ]

================================================================================
FILE: core/migrations/0009_alter_condo_options_alter_parkingspot_options_and_more.py
================================================================================
# Generated by Django 5.2.6 on 2025-09-18 18:34

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0008_booking_workflow_and_file"),
    ]

    operations = [
        migrations.AlterModelOptions(
            name="condo",
            options={},
        ),
        migrations.AlterModelOptions(
            name="parkingspot",
            options={},
        ),
        migrations.AlterModelOptions(
            name="unit",
            options={},
        ),
        migrations.AlterModelOptions(
            name="unitparkingassignment",
            options={"ordering": ["-start_date"]},
        ),
        migrations.AlterField(
            model_name="condo",
            name="city",
            field=models.CharField(blank=True, max_length=120),
        ),
        migrations.AlterField(
            model_name="condo",
            name="code",
            field=models.CharField(max_length=50, unique=True),
        ),
        migrations.AlterField(
            model_name="condo",
            name="province",
            field=models.CharField(blank=True, max_length=120),
        ),
        migrations.AlterField(
            model_name="parkingspot",
            name="spot_type",
            field=models.CharField(
                choices=[("RESIDENT", "Resident"), ("VISITOR", "Visitor")],
                default="RESIDENT",
                max_length=16,
            ),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="guest_first_name",
            field=models.CharField(max_length=120),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="guest_last_name",
            field=models.CharField(max_length=120),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="id_country",
            field=models.CharField(blank=True, max_length=120),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="id_number",
            field=models.CharField(blank=True, max_length=120),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="id_province_state",
            field=models.CharField(blank=True, max_length=120),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="id_type",
            field=models.CharField(
                choices=[
                    ("LICENSE", "Driver’s License"),
                    ("PASSPORT", "Passport"),
                    ("OTHER", "Other"),
                ],
                default="LICENSE",
                max_length=16,
            ),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="parking_spot",
            field=models.ForeignKey(
                blank=True,
                null=True,
                on_delete=django.db.models.deletion.SET_NULL,
                related_name="bookings",
                to="core.parkingspot",
            ),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="unit",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="bookings",
                to="core.unit",
            ),
        ),
        migrations.AlterField(
            model_name="shorttermbooking",
            name="vehicle_plate",
            field=models.CharField(blank=True, max_length=50),
        ),
        migrations.AlterField(
            model_name="unit",
            name="status",
            field=models.CharField(
                choices=[
                    ("OWNER_OCCUPIED", "Owner Occupied"),
                    ("TENANT", "Tenant"),
                    ("VACANT", "Vacant"),
                ],
                default="OWNER_OCCUPIED",
                max_length=32,
            ),
        ),
        migrations.AlterField(
            model_name="unit",
            name="unit_number",
            field=models.CharField(max_length=50),
        ),
        migrations.AlterField(
            model_name="unitparkingassignment",
            name="parking_spot",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="assignments",
                to="core.parkingspot",
            ),
        ),
    ]

================================================================================
FILE: core/migrations/__init__.py
================================================================================


================================================================================
FILE: core/models.py
================================================================================
# core/models.py
from django.conf import settings
from django.db import models


class TimeStampedModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


class Condo(TimeStampedModel):
    name = models.CharField(max_length=200)
    code = models.CharField(max_length=50, unique=True)  # short identifier
    address = models.CharField(max_length=255, blank=True)
    city = models.CharField(max_length=120, blank=True)
    province = models.CharField(max_length=120, blank=True)

    def __str__(self) -> str:
        return f"{self.name} ({self.code})"


class Unit(TimeStampedModel):
    class Status(models.TextChoices):
        OWNER_OCCUPIED = "OWNER_OCCUPIED", "Owner Occupied"
        TENANT = "TENANT", "Tenant"
        VACANT = "VACANT", "Vacant"

    condo = models.ForeignKey(Condo, on_delete=models.CASCADE, related_name="units")
    unit_number = models.CharField(max_length=50)
    owner_name = models.CharField(max_length=200, blank=True)
    owner_email = models.EmailField(blank=True)
    status = models.CharField(
        max_length=32, choices=Status.choices, default=Status.OWNER_OCCUPIED
    )

    class Meta:
        unique_together = ("condo", "unit_number")

    def __str__(self) -> str:
        return f"{self.condo.code}-{self.unit_number}"


class ParkingSpot(TimeStampedModel):
    class SpotType(models.TextChoices):
        RESIDENT = "RESIDENT", "Resident"
        VISITOR = "VISITOR", "Visitor"

    condo = models.ForeignKey(
        Condo, on_delete=models.CASCADE, related_name="parking_spots"
    )
    code = models.CharField(max_length=50)  # e.g., P1-123
    level = models.CharField(max_length=50, blank=True)
    spot_type = models.CharField(
        max_length=16, choices=SpotType.choices, default=SpotType.RESIDENT
    )

    class Meta:
        unique_together = ("condo", "code")

    def __str__(self) -> str:
        return f"{self.condo.code}-{self.code}"


class UnitParkingAssignment(TimeStampedModel):
    unit = models.ForeignKey(
        Unit, on_delete=models.CASCADE, related_name="parking_assignments"
    )
    parking_spot = models.ForeignKey(
        ParkingSpot, on_delete=models.CASCADE, related_name="assignments"
    )
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)  # open-ended
    is_primary = models.BooleanField(default=True)

    class Meta:
        ordering = ["-start_date"]

    def __str__(self) -> str:
        return f"{self.unit} → {self.parking_spot}"


class ShortTermBooking(TimeStampedModel):
    class IdType(models.TextChoices):
        LICENSE = "LICENSE", "Driver’s License"
        PASSPORT = "PASSPORT", "Passport"
        OTHER = "OTHER", "Other"

    # lower-case to match views (.approve/.reject) and serializer
    class Status(models.TextChoices):
        PENDING = "pending", "Pending"
        APPROVED = "approved", "Approved"
        REJECTED = "rejected", "Rejected"
        CANCELLED = "cancelled", "Cancelled"

    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name="bookings")

    # guest info
    guest_first_name = models.CharField(max_length=120)
    guest_last_name = models.CharField(max_length=120)
    id_type = models.CharField(
        max_length=16, choices=IdType.choices, default=IdType.LICENSE
    )
    id_number = models.CharField(max_length=120, blank=True)
    id_country = models.CharField(max_length=120, blank=True)
    id_province_state = models.CharField(max_length=120, blank=True)

    # vehicle & parking
    vehicle_plate = models.CharField(max_length=50, blank=True)
    parking_spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="bookings",
    )

    # stay dates (date granularity is fine)
    check_in = models.DateField()
    check_out = models.DateField()

    status = models.CharField(
        max_length=16, choices=Status.choices, default=Status.PENDING
    )
    notes = models.TextField(blank=True)

    # RBAC workflow tracking (matches serializer)
    submitted_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="bookings_submitted",
    )
    reviewed_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="bookings_reviewed",
    )
    reviewed_at = models.DateTimeField(null=True, blank=True)

    # optional file upload for ID image/PDF
    id_document = models.FileField(upload_to="ids/", null=True, blank=True)

    class Meta:
        ordering = ["-check_in"]

    def __str__(self) -> str:
        return f"Booking {self.unit} {self.check_in}→{self.check_out} ({self.status})"

================================================================================
FILE: core/serializers.py
================================================================================
# core/serializers.py
from django.contrib.auth import get_user_model
from rest_framework import serializers

from .models import Condo, ParkingSpot, ShortTermBooking, Unit, UnitParkingAssignment

User = get_user_model()


class CondoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Condo
        fields = "__all__"


class UnitSerializer(serializers.ModelSerializer):
    condo_name = serializers.CharField(source="condo.name", read_only=True)

    class Meta:
        model = Unit
        fields = [
            "id",
            "condo",
            "condo_name",
            "unit_number",
            "owner_name",
            "owner_email",
            "status",
            "created_at",
            "updated_at",
        ]


class ParkingSpotSerializer(serializers.ModelSerializer):
    condo_name = serializers.CharField(source="condo.name", read_only=True)

    class Meta:
        model = ParkingSpot
        fields = [
            "id",
            "condo",
            "condo_name",
            "code",
            "level",
            "spot_type",
            "created_at",
            "updated_at",
        ]


class UnitParkingAssignmentSerializer(serializers.ModelSerializer):
    unit_display = serializers.CharField(source="unit.__str__", read_only=True)
    spot_display = serializers.CharField(source="parking_spot.__str__", read_only=True)

    class Meta:
        model = UnitParkingAssignment
        fields = [
            "id",
            "unit",
            "unit_display",
            "parking_spot",
            "spot_display",
            "start_date",
            "end_date",
            "is_primary",
            "created_at",
            "updated_at",
        ]

    def validate(self, attrs):
        unit = attrs.get("unit") or getattr(self.instance, "unit", None)
        spot = attrs.get("parking_spot") or getattr(self.instance, "parking_spot", None)
        if unit and spot and unit.condo_id != spot.condo_id:
            raise serializers.ValidationError(
                "Unit and Parking Spot must belong to the same condo."
            )
        return attrs


class ShortTermBookingSerializer(serializers.ModelSerializer):
    unit_display = serializers.CharField(source="unit.__str__", read_only=True)
    spot_display = serializers.CharField(source="parking_spot.__str__", read_only=True)

    # RBAC workflow fields
    submitted_by_username = serializers.CharField(
        source="submitted_by.username", read_only=True
    )
    reviewed_by_username = serializers.CharField(
        source="reviewed_by.username", read_only=True
    )
    id_document = serializers.FileField(required=False, allow_null=True)

    class Meta:
        model = ShortTermBooking
        fields = [
            "id",
            "unit",
            "unit_display",
            "guest_first_name",
            "guest_last_name",
            "id_type",
            "id_number",
            "id_country",
            "id_province_state",
            "vehicle_plate",
            "parking_spot",
            "spot_display",
            "check_in",
            "check_out",
            "status",
            "notes",
            "id_document",
            "submitted_by",
            "submitted_by_username",
            "reviewed_by",
            "reviewed_by_username",
            "reviewed_at",
            "created_at",
            "updated_at",
        ]
        read_only_fields = [
            "id",
            "submitted_by",
            "submitted_by_username",
            "reviewed_by",
            "reviewed_by_username",
            "reviewed_at",
            "created_at",
            "updated_at",
        ]

    def validate(self, attrs):
        check_in = attrs.get("check_in") or getattr(self.instance, "check_in", None)
        check_out = attrs.get("check_out") or getattr(self.instance, "check_out", None)
        if check_in and check_out and check_out < check_in:
            raise serializers.ValidationError(
                "check_out must be the same day or after check_in."
            )

        unit = attrs.get("unit") or getattr(self.instance, "unit", None)
        spot = attrs.get("parking_spot") or getattr(self.instance, "parking_spot", None)
        if unit and spot and unit.condo_id != spot.condo_id:
            raise serializers.ValidationError(
                "Selected parking spot must belong to the same condo as the unit."
            )
        return attrs

    def create(self, validated_data):
        # record who submitted (owner/agent/concierge/pm)
        user = self.context["request"].user if "request" in self.context else None
        if user and user.is_authenticated:
            validated_data["submitted_by"] = user
        return super().create(validated_data)

================================================================================
FILE: core/services/__init__.py
================================================================================


================================================================================
FILE: core/services/csv_assignments.py
================================================================================
import csv
import io
from datetime import date, datetime
from typing import Any, Dict, List, Tuple

from django.db import transaction

from core.models import Condo, ParkingSpot, Unit, UnitParkingAssignment

CSV_FIELDS_EXPORT = [
    "condo_code",
    "unit_number",
    "parking_code",
    "status",  # derived: active / inactive
    "effective_start",
    "effective_end",
]

# We accept either start_date/end_date OR effective_start/effective_end on import
CSV_FIELDS_IMPORT_ALLOWED = {
    "condo_code",
    "unit_number",
    "parking_code",
    "is_primary",
    "start_date",
    "end_date",
    "effective_start",
    "effective_end",
    "status",  # ignored if present (we compute it)
}


def _parse_date(val: str):
    if not val:
        return None
    val = str(val).strip()
    if not val:
        return None
    try:
        return datetime.strptime(val, "%Y-%m-%d").date()
    except Exception:
        return date.fromisoformat(val)


def export_assignments_to_csv() -> Tuple[str, bytes]:
    """
    Build a canonical CSV of current assignments.

    Columns:
      condo_code, unit_number, parking_code, status, effective_start, effective_end
    - status is computed: 'active' if end is None or >= today; else 'inactive'
    """
    rows: List[List[str]] = []
    today = date.today()

    qs = UnitParkingAssignment.objects.select_related(
        "unit__condo", "parking_spot__condo"
    ).order_by(
        "unit__condo__code", "unit__unit_number", "parking_spot__code", "start_date"
    )

    for a in qs:
        condo_code = a.unit.condo.code
        unit_number = a.unit.unit_number
        parking_code = a.parking_spot.code
        eff_start = a.start_date.isoformat() if a.start_date else ""
        eff_end = a.end_date.isoformat() if a.end_date else ""
        is_active = (a.end_date is None) or (a.end_date >= today)
        status = "active" if is_active else "inactive"
        rows.append([condo_code, unit_number, parking_code, status, eff_start, eff_end])

    buffer = io.StringIO(newline="")
    writer = csv.writer(buffer)
    writer.writerow(CSV_FIELDS_EXPORT)
    writer.writerows(rows)

    content_bytes = buffer.getvalue().encode("utf-8")
    filename = "assignments.csv"
    return filename, content_bytes


def _errors_to_csv(error_rows: List[Dict[str, Any]]) -> str:
    sio = io.StringIO(newline="")
    fieldnames = ["row_number", "error", "condo_code", "unit_number", "parking_code"]
    writer = csv.DictWriter(sio, fieldnames=fieldnames)
    writer.writeheader()
    for r in error_rows:
        row = r.get("row", {}) or {}
        writer.writerow(
            {
                "row_number": r.get("row_number"),
                "error": r.get("error"),
                "condo_code": (row.get("condo_code") or "").strip(),
                "unit_number": (row.get("unit_number") or "").strip(),
                "parking_code": (row.get("parking_code") or "").strip(),
            }
        )
    return sio.getvalue()


@transaction.atomic
def import_assignments_from_csv(uploaded_file, dry_run: bool = False) -> Dict[str, Any]:
    """
    Upsert assignments from a CSV file.

    Accepted headers (case-sensitive):
      required: condo_code, unit_number, parking_code
      optional: is_primary, start_date, end_date OR effective_start, effective_end
      optional: status (ignored; computed)

    When dry_run=True:
      - perform full validation
      - return the same structure but do NOT write any DB changes
    """
    # read file payload
    if hasattr(uploaded_file, "read"):
        raw = uploaded_file.read()
        text = (
            raw.decode("utf-8-sig") if isinstance(raw, (bytes, bytearray)) else str(raw)
        )
    else:
        text = (
            uploaded_file.decode("utf-8-sig")
            if isinstance(uploaded_file, (bytes, bytearray))
            else str(uploaded_file)
        )

    f = io.StringIO(text)
    reader = csv.DictReader(f)

    field_set = set(reader.fieldnames or [])
    missing = {"condo_code", "unit_number", "parking_code"} - field_set
    if missing:
        errors = [
            {
                "row_number": 0,
                "error": f"Missing required columns: {', '.join(sorted(missing))}",
                "row": {},
            }
        ]
        return {
            "created": 0,
            "updated": 0,
            "errors": len(errors),
            "error_rows": errors,
            "total_rows": 0,
            "errors_csv": _errors_to_csv(errors),
        }

    created = 0
    updated = 0
    errors = 0
    error_rows: List[Dict[str, Any]] = []
    total = 0

    # Keep a list of objects to write only if not dry_run
    pending_updates: List[UnitParkingAssignment] = []
    pending_creates: List[UnitParkingAssignment] = []

    for idx, row in enumerate(reader, start=2):  # header is line 1
        total += 1
        try:
            condo_code = (row.get("condo_code") or "").strip()
            unit_number = (row.get("unit_number") or "").strip()
            parking_code = (row.get("parking_code") or "").strip()
            is_primary_raw = (row.get("is_primary") or "").strip()

            start_raw = (
                row.get("start_date") or row.get("effective_start") or ""
            ).strip()
            end_raw = (row.get("end_date") or row.get("effective_end") or "").strip()

            if not (condo_code and unit_number and parking_code):
                raise ValueError("condo_code, unit_number, parking_code are required")

            try:
                condo = Condo.objects.get(code=condo_code)
            except Condo.DoesNotExist:
                raise ValueError(f"Condo not found: code={condo_code}")

            try:
                unit = Unit.objects.get(condo=condo, unit_number=unit_number)
            except Unit.DoesNotExist:
                raise ValueError(
                    f"Unit not found: condo={condo_code} unit_number={unit_number}"
                )

            try:
                spot = ParkingSpot.objects.get(condo=condo, code=parking_code)
            except ParkingSpot.DoesNotExist:
                raise ValueError(
                    f"Parking spot not found: condo={condo_code} code={parking_code}"
                )

            is_primary = None
            if is_primary_raw != "":
                is_primary = str(is_primary_raw).lower() in {
                    "1",
                    "true",
                    "yes",
                    "y",
                    "t",
                }

            start_date = _parse_date(start_raw) if start_raw else None
            end_date = _parse_date(end_raw) if end_raw else None

            obj, existed = UnitParkingAssignment.objects.get_or_create(
                unit=unit,
                parking_spot=spot,
                defaults={
                    "start_date": start_date,
                    "end_date": end_date,
                    "is_primary": bool(is_primary) if is_primary is not None else False,
                },
            )
            if existed:
                if dry_run:
                    created += 1  # would be created
                else:
                    created += 1
            else:
                changed = False
                if start_date is not None and obj.start_date != start_date:
                    obj.start_date = start_date
                    changed = True
                if end_date is not None and obj.end_date != end_date:
                    obj.end_date = end_date
                    changed = True
                if is_primary is not None and obj.is_primary != bool(is_primary):
                    obj.is_primary = bool(is_primary)
                    changed = True
                if changed:
                    if dry_run:
                        updated += 1  # would be updated
                    else:
                        pending_updates.append(obj)

        except Exception as e:
            errors += 1
            error_rows.append({"row_number": idx, "error": str(e), "row": row})

    # Apply writes if not dry_run
    if not dry_run:
        if pending_creates:
            UnitParkingAssignment.objects.bulk_create(
                pending_creates, ignore_conflicts=True
            )
        for obj in pending_updates:
            obj.save(update_fields=["start_date", "end_date", "is_primary"])

    return {
        "created": created,
        "updated": updated,
        "errors": errors,
        "error_rows": error_rows,
        "total_rows": total,
        "errors_csv": _errors_to_csv(error_rows) if errors else "",
    }

================================================================================
FILE: core/services/csv_roundtrip.py
================================================================================
# core/services/csv_roundtrip.py
import csv
from io import StringIO

from .models import UnitParkingAssignment

CSV_HEADERS = [
    "condo_code",
    "unit_number",
    "spot_code",
    "start_date",
    "end_date",
    "is_primary",
]


def export_assignments_csv_text() -> str:
    out = StringIO()
    w = csv.writer(out)
    w.writerow(CSV_HEADERS)
    qs = UnitParkingAssignment.objects.select_related(
        "unit__condo", "parking_spot__condo"
    ).order_by("unit__condo__code", "unit__unit_number", "-start_date")
    for a in qs:
        w.writerow(
            [
                a.unit.condo.code,
                a.unit.unit_number,
                a.parking_spot.code,
                a.start_date.isoformat(),
                a.end_date.isoformat() if a.end_date else "",
                str(a.is_primary).lower(),
            ]
        )
    return out.getvalue()

================================================================================
FILE: core/tests/test_fixture_smoke.py
================================================================================
from django.test import TestCase

from core.models import (
    Condo,
    ParkingSpot,
    ShortTermBooking,
    Unit,
    UnitParkingAssignment,
)


class FixtureSmokeTests(TestCase):
    fixtures = ["sample_data.json"]

    def test_counts_and_linkage(self):
        self.assertEqual(Condo.objects.count(), 1)
        self.assertEqual(Unit.objects.count(), 2)
        self.assertEqual(ParkingSpot.objects.count(), 2)
        self.assertEqual(UnitParkingAssignment.objects.count(), 2)
        # linkage: confirm each unit has a spot via assignment
        a1 = UnitParkingAssignment.objects.get(unit__unit_number="905")
        self.assertIsNotNone(a1.parking_spot_id)
        # bookings fixture present
        self.assertEqual(ShortTermBooking.objects.count(), 1)

================================================================================
FILE: core/tests.py
================================================================================
from django.apps import apps
from django.test import TestCase


class SmokeTest(TestCase):
    def test_core_app_loaded(self):
        self.assertTrue(apps.is_installed("core"))

================================================================================
FILE: core/urls.py
================================================================================
from django.urls import include, path
from rest_framework.routers import DefaultRouter

from .views import (
    CondoViewSet,
    ParkingSpotViewSet,
    ShortTermBookingViewSet,
    UnitParkingAssignmentViewSet,
    UnitViewSet,
)
from .views_assignments_csv import AssignmentsCSVExportView, AssignmentsCSVImportView
from .views_lookup import SpotUnitLookupView, UnitParkingLookupView

router = DefaultRouter()
router.register(r"condos", CondoViewSet, basename="condo")
router.register(r"units", UnitViewSet, basename="unit")
router.register(r"parking-spots", ParkingSpotViewSet, basename="parkingspot")
router.register(
    r"unit-parking-assignments",
    UnitParkingAssignmentViewSet,
    basename="unitparkingassignment",
)
router.register(r"bookings", ShortTermBookingViewSet, basename="booking")

urlpatterns = [
    path("", include(router.urls)),
    path("assignments/export.csv", AssignmentsCSVExportView.as_view()),
    path("assignments/import.csv", AssignmentsCSVImportView.as_view()),
    path("units/<int:unit_id>/parking", UnitParkingLookupView.as_view()),
    path("spots/<int:spot_id>/unit", SpotUnitLookupView.as_view()),
    path("reports/", include("core.urls_reports")),
]

================================================================================
FILE: core/urls_reports.py
================================================================================
# core/urls_reports.py
from django.urls import path

from .views_reports import (
    AvailableSpotsReportView,
    UnitBookingsReportView,
    UpcomingCheckpointsReportView,
)

urlpatterns = [
    path("unit/<int:unit_id>/bookings", UnitBookingsReportView.as_view()),
    path("available-spots", AvailableSpotsReportView.as_view()),
    path("upcoming-checkpoints", UpcomingCheckpointsReportView.as_view()),
]

================================================================================
FILE: core/views.py
================================================================================
# core/views.py
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import permissions, status, viewsets
from rest_framework.decorators import action
from rest_framework.response import Response

from accounts.models import Role, UnitAccess
from accounts.permissions import (
    IsAuthenticatedJWT,
    IsConcierge,
    IsPropertyManager,
    ReadOnly,
)

from .filters import ShortTermBookingFilter
from .models import Condo, ParkingSpot, ShortTermBooking, Unit, UnitParkingAssignment
from .serializers import (
    CondoSerializer,
    ParkingSpotSerializer,
    ShortTermBookingSerializer,
    UnitParkingAssignmentSerializer,
    UnitSerializer,
)


# ----- helpers -----
def user_units_qs(user):
    """Units this user can access (PM: all; others via UnitAccess)."""
    if not user.is_authenticated:
        return Unit.objects.none()
    role = getattr(getattr(user, "profile", None), "role", None)
    if role == Role.PROPERTY_MANAGER:
        return Unit.objects.all()
    unit_ids = UnitAccess.objects.filter(user=user).values_list("unit_id", flat=True)
    return Unit.objects.filter(id__in=unit_ids)


# ----- viewsets -----
class CondoViewSet(viewsets.ModelViewSet):
    queryset = Condo.objects.all()
    serializer_class = CondoSerializer
    permission_classes = [IsAuthenticatedJWT & (IsPropertyManager | ReadOnly)]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["code", "city", "province"]
    ordering = ["code"]


class UnitViewSet(viewsets.ModelViewSet):
    serializer_class = UnitSerializer
    permission_classes = [IsAuthenticatedJWT & (IsPropertyManager | ReadOnly)]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["condo", "status", "unit_number"]
    ordering = ["unit_number"]

    def get_queryset(self):
        return user_units_qs(self.request.user).select_related("condo")


class ParkingSpotViewSet(viewsets.ModelViewSet):
    queryset = ParkingSpot.objects.select_related("condo").all()
    serializer_class = ParkingSpotSerializer
    permission_classes = [IsAuthenticatedJWT & (IsPropertyManager | ReadOnly)]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["condo", "spot_type", "level", "code"]
    ordering = ["code"]


class UnitParkingAssignmentViewSet(viewsets.ModelViewSet):
    serializer_class = UnitParkingAssignmentSerializer
    permission_classes = [IsAuthenticatedJWT & (IsPropertyManager | ReadOnly)]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ["unit", "parking_spot", "is_primary", "unit__unit_number"]
    ordering = ["-start_date", "-created_at"]

    def get_queryset(self):
        units = user_units_qs(self.request.user)
        return UnitParkingAssignment.objects.select_related(
            "unit", "parking_spot"
        ).filter(unit__in=units)


class ShortTermBookingViewSet(viewsets.ModelViewSet):
    serializer_class = ShortTermBookingSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_class = ShortTermBookingFilter
    ordering = ["-check_in", "-created_at"]

    def get_permissions(self):
        """
        - PM: full access (list/create/update/delete + approve/reject).
        - Concierge: list/retrieve/update status (approve/reject). Cannot create/destroy.
        - Agent/Owner (via UnitAccess): can create & read their own bookings only.
        """
        role = getattr(getattr(self.request.user, "profile", None), "role", None)
        if role == Role.PROPERTY_MANAGER:
            return [IsAuthenticatedJWT()]
        if role == Role.CONCIERGE:
            if self.action in [
                "list",
                "retrieve",
                "update",
                "partial_update",
                "approve",
                "reject",
            ]:
                return [IsAuthenticatedJWT()]
            return [IsAuthenticatedJWT(), ReadOnly()]
        # agents/owners
        if self.action in ["create", "list", "retrieve"]:
            return [IsAuthenticatedJWT()]
        return [IsAuthenticatedJWT(), ReadOnly()]

    def get_queryset(self):
        user = self.request.user
        role = getattr(getattr(user, "profile", None), "role", None)
        qs = ShortTermBooking.objects.select_related(
            "unit", "parking_spot", "submitted_by", "reviewed_by"
        )
        if role in [Role.PROPERTY_MANAGER, Role.CONCIERGE]:
            return qs
        units = user_units_qs(user)
        return qs.filter(unit__in=units)

    def perform_create(self, serializer):
        # agents/owners can only submit for units they have access to
        user = self.request.user
        role = getattr(getattr(user, "profile", None), "role", None)
        if role not in [Role.PROPERTY_MANAGER, Role.CONCIERGE]:
            unit = serializer.validated_data.get("unit")
            if unit not in list(user_units_qs(user)):
                raise permissions.PermissionDenied("No access to selected unit.")
        serializer.save()

    @action(detail=True, methods=["POST"])
    def approve(self, request, pk=None):
        booking = self.get_object()
        role = getattr(getattr(request.user, "profile", None), "role", None)
        if role not in [Role.PROPERTY_MANAGER, Role.CONCIERGE]:
            return Response(
                {"detail": "Not allowed."}, status=status.HTTP_403_FORBIDDEN
            )
        booking.status = "approved"
        booking.reviewed_by = request.user
        from django.utils import timezone

        booking.reviewed_at = timezone.now()
        booking.save(update_fields=["status", "reviewed_by", "reviewed_at"])
        return Response(
            ShortTermBookingSerializer(booking, context={"request": request}).data
        )

    @action(detail=True, methods=["POST"])
    def reject(self, request, pk=None):
        booking = self.get_object()
        role = getattr(getattr(request.user, "profile", None), "role", None)
        if role not in [Role.PROPERTY_MANAGER, Role.CONCIERGE]:
            return Response(
                {"detail": "Not allowed."}, status=status.HTTP_403_FORBIDDEN
            )
        booking.status = "rejected"
        booking.reviewed_by = request.user
        from django.utils import timezone

        booking.reviewed_at = timezone.now()
        booking.save(update_fields=["status", "reviewed_by", "reviewed_at"])
        return Response(
            ShortTermBookingSerializer(booking, context={"request": request}).data
        )

================================================================================
FILE: core/views_assignments_csv.py
================================================================================
from datetime import datetime
from pathlib import Path

from django.conf import settings
from django.http import HttpResponse
from drf_spectacular.utils import extend_schema
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView

from accounts.permissions import IsAuthenticatedJWT, IsPropertyManager

from .services.csv_assignments import (
    export_assignments_to_csv,
    import_assignments_from_csv,
)


@extend_schema(tags=["Assignments"])
class AssignmentsCSVExportView(APIView):
    # PM only
    permission_classes = [IsAuthenticatedJWT & IsPropertyManager]

    def get(self, request):
        filename, content = export_assignments_to_csv()
        response = HttpResponse(content, content_type="text/csv; charset=utf-8")
        response["Content-Disposition"] = f'attachment; filename="{filename}"'
        return response


@extend_schema(tags=["Assignments"])
class AssignmentsCSVImportView(APIView):
    """
    POST multipart/form-data with 'file'.
    Optional query: ?dry_run=1
    Returns JSON summary and, if errors, a link to an error CSV file when not dry_run.
    """

    # PM only
    permission_classes = [IsAuthenticatedJWT & IsPropertyManager]

    def post(self, request):
        file = request.FILES.get("file")
        if not file:
            return Response(
                {"detail": "file is required"}, status=status.HTTP_400_BAD_REQUEST
            )

        dry_run = str(request.query_params.get("dry_run", "0")).lower() in {
            "1",
            "true",
            "yes",
            "y",
        }
        result = import_assignments_from_csv(file, dry_run=dry_run)

        errors_path = ""
        if result.get("errors") and not dry_run:
            media_root = Path(getattr(settings, "MEDIA_ROOT", "media"))
            out_dir = media_root / "import_errors"
            out_dir.mkdir(parents=True, exist_ok=True)
            ts = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
            out_file = out_dir / f"assignments_import_errors_{ts}.csv"
            out_file.write_text(result.get("errors_csv", ""), encoding="utf-8")
            errors_path = (
                f"{settings.MEDIA_URL.rstrip('/')}/import_errors/{out_file.name}"
            )

        payload = {
            "created": result.get("created"),
            "updated": result.get("updated"),
            "errors": result.get("errors"),
            "total_rows": result.get("total_rows"),
            "dry_run": dry_run,
            "errors_csv_url": errors_path,
            "error_rows": result.get("error_rows", []),
        }
        return Response(payload, status=status.HTTP_200_OK)

================================================================================
FILE: core/views_lookup.py
================================================================================
from drf_spectacular.utils import extend_schema
from rest_framework import status
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView

from .models import ParkingSpot, Unit, UnitParkingAssignment


@extend_schema(tags=["Lookups"])
class UnitParkingLookupView(APIView):
    """
    GET /api/units/<unit_id>/parking
    Returns current and historical assignments for a unit.
    """

    permission_classes = [IsAuthenticated]

    def get(self, request, unit_id: int):
        try:
            unit = Unit.objects.get(pk=unit_id)
        except Unit.DoesNotExist:
            return Response(
                {"detail": "Unit not found."}, status=status.HTTP_404_NOT_FOUND
            )

        qs = (
            UnitParkingAssignment.objects.select_related("parking_spot", "unit__condo")
            .filter(unit=unit)
            .order_by("-start_date", "-id")
        )
        results = []
        for a in qs:
            results.append(
                {
                    "assignment_id": a.id,
                    "unit": str(a.unit),
                    "spot_id": a.parking_spot_id,
                    "spot_code": a.parking_spot.code if a.parking_spot_id else None,
                    "condo": a.unit.condo.code,
                    "start_date": a.start_date.isoformat() if a.start_date else None,
                    "end_date": a.end_date.isoformat() if a.end_date else None,
                    "is_active": a.end_date is None,
                    "is_primary": a.is_primary,
                }
            )
        return Response({"unit": str(unit), "count": len(results), "results": results})


@extend_schema(tags=["Lookups"])
class SpotUnitLookupView(APIView):
    """
    GET /api/spots/<spot_id>/unit
    Returns the current assigned unit (if any) and history for a spot.
    """

    permission_classes = [IsAuthenticated]

    def get(self, request, spot_id: int):
        try:
            spot = ParkingSpot.objects.get(pk=spot_id)
        except ParkingSpot.DoesNotExist:
            return Response(
                {"detail": "Parking spot not found."}, status=status.HTTP_404_NOT_FOUND
            )

        qs = (
            UnitParkingAssignment.objects.select_related("unit", "unit__condo")
            .filter(parking_spot=spot)
            .order_by("-start_date", "-id")
        )
        history = []
        current_unit = None
        for a in qs:
            item = {
                "assignment_id": a.id,
                "unit_id": a.unit_id,
                "unit": str(a.unit),
                "condo": a.unit.condo.code,
                "start_date": a.start_date.isoformat() if a.start_date else None,
                "end_date": a.end_date.isoformat() if a.end_date else None,
                "is_active": a.end_date is None,
                "is_primary": a.is_primary,
            }
            history.append(item)
            if a.end_date is None and current_unit is None:
                current_unit = {"unit_id": a.unit_id, "unit": str(a.unit)}

        return Response(
            {
                "spot": f"{spot.condo.code}-{spot.code}",
                "current_unit": current_unit,
                "history_count": len(history),
                "history": history,
            }
        )

================================================================================
FILE: core/views_reports.py
================================================================================
# core/views_reports.py
from datetime import date, timedelta

from django.db.models import Q
from django.utils.dateparse import parse_date
from drf_spectacular.utils import extend_schema
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView

from accounts.permissions import IsAuthenticatedJWT

from .models import ParkingSpot, ShortTermBooking, Unit, UnitParkingAssignment


def _parse_window(window_param: str) -> timedelta:
    if not window_param:
        return timedelta(days=7)
    try:
        if window_param.endswith("d"):
            return timedelta(days=int(window_param[:-1]))
        return timedelta(days=int(window_param))
    except Exception:
        return timedelta(days=7)


@extend_schema(tags=["Reports"])
class UnitBookingsReportView(APIView):
    """
    GET /reports/unit/{id}/bookings
    Returns bookings for a unit (past + upcoming, newest first).
    Query params:
      - status (optional): pending|approved|rejected|cancelled
    """

    permission_classes = [IsAuthenticatedJWT]

    def get(self, request, unit_id: int, *args, **kwargs):
        try:
            unit = Unit.objects.get(pk=unit_id)
        except Unit.DoesNotExist:
            return Response(
                {"detail": "Unit not found."}, status=status.HTTP_404_NOT_FOUND
            )

        qs = (
            ShortTermBooking.objects.select_related("unit", "parking_spot")
            .filter(unit=unit)
            .order_by("-check_in", "-created_at")
        )
        status_filter = request.query_params.get("status")
        if status_filter:
            qs = qs.filter(status=status_filter)

        data = [
            {
                "id": b.id,
                "unit": str(b.unit),
                "parking_spot": str(b.parking_spot) if b.parking_spot_id else None,
                "guest_first_name": b.guest_first_name,
                "guest_last_name": b.guest_last_name,
                "vehicle_plate": b.vehicle_plate,
                "check_in": b.check_in.isoformat(),
                "check_out": b.check_out.isoformat(),
                "status": b.status,
                "notes": b.notes,
            }
            for b in qs
        ]
        return Response({"unit": str(unit), "count": len(data), "results": data})


@extend_schema(tags=["Reports"])
class AvailableSpotsReportView(APIView):
    """
    GET /reports/available-spots?date=YYYY-MM-DD&condo_id=<id>
    Lists resident spots in a condo that are NOT assigned on that date and NOT booked for that date.
    """

    permission_classes = [IsAuthenticatedJWT]

    def get(self, request, *args, **kwargs):
        d_str = request.query_params.get("date")
        condo_id = request.query_params.get("condo_id")
        d = parse_date(d_str) if d_str else date.today()
        if not d:
            return Response(
                {"detail": "Invalid date."}, status=status.HTTP_400_BAD_REQUEST
            )
        if not condo_id:
            return Response(
                {"detail": "Missing condo_id."}, status=status.HTTP_400_BAD_REQUEST
            )

        spots = ParkingSpot.objects.filter(condo_id=condo_id)

        active_assignments = UnitParkingAssignment.objects.filter(
            parking_spot__in=spots,
            start_date__lte=d,
        ).filter(Q(end_date__isnull=True) | Q(end_date__gte=d))
        assigned_spot_ids = set(
            active_assignments.values_list("parking_spot_id", flat=True)
        )

        day_q = Q(check_in__lte=d, check_out__gte=d)
        day_booked_spot_ids = set(
            ShortTermBooking.objects.filter(parking_spot__in=spots)
            .filter(day_q)
            .values_list("parking_spot_id", flat=True)
        )

        unavailable = assigned_spot_ids.union(day_booked_spot_ids)
        available = spots.exclude(id__in=unavailable).order_by("code")

        results = [
            {"id": s.id, "spot": str(s), "code": s.code, "level": s.level}
            for s in available
        ]
        return Response(
            {
                "date": d.isoformat(),
                "condo_id": int(condo_id),
                "count": len(results),
                "results": results,
            }
        )


@extend_schema(tags=["Reports"])
class UpcomingCheckpointsReportView(APIView):
    """
    GET /reports/upcoming-checkpoints?window=7d
    Returns bookings starting within the next 'window' days.
    """

    permission_classes = [IsAuthenticatedJWT]

    def get(self, request, *args, **kwargs):
        window = _parse_window(request.query_params.get("window"))
        today = date.today()
        end = today + window
        qs = (
            ShortTermBooking.objects.select_related("unit", "parking_spot")
            .filter(check_in__gte=today, check_in__lte=end)
            .order_by("check_in", "unit__unit_number")
        )
        data = [
            {
                "id": b.id,
                "check_in": b.check_in.isoformat(),
                "check_out": b.check_out.isoformat(),
                "unit": str(b.unit),
                "parking_spot": str(b.parking_spot) if b.parking_spot_id else None,
                "guest": f"{b.guest_first_name} {b.guest_last_name}",
                "status": b.status,
            }
            for b in qs
        ]
        return Response(
            {"window_days": window.days, "count": len(data), "results": data}
        )

================================================================================
FILE: docker-compose.yml
================================================================================
version: "3.9"
services:
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: app
      POSTGRES_PASSWORD: apppass
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  web:
    build: .
    command: gunicorn condo_backend.wsgi:application --bind 0.0.0.0:8000 --workers 3 --timeout 120
    environment:
      DJANGO_SETTINGS_MODULE: condo_backend.settings
      DB_ENGINE: postgres
      DB_NAME: app
      DB_USER: app
      DB_PASSWORD: apppass
      DB_HOST: db
      DB_PORT: "5432"
      SECRET_KEY: dev-secret-change-me
      DEBUG: "True"
      ALLOWED_HOSTS: "*"
    ports:
      - "8000:8000"
    depends_on:
      - db

volumes:
  pgdata:

================================================================================
FILE: export_repo_to_text.py
================================================================================
#!/usr/bin/env python3
"""
Export a codebase into a single *plain text* file for ChatGPT review.

Usage:
  python export_repo_to_text.py [OUTPUT_PATH]
                                [--max-bytes 200000]
                                [--include-sensitive]
                                [--include-binaries]
                                [--autocommit]
                                [--commit-message "msg"]
                                [--git-include-ignored]
                                [--git-init]

Defaults:
  OUTPUT_PATH: repo_dump.txt
  --max-bytes: 200000 (skip files larger than this; set 0 to disable size check)

Notes:
  - By default, file discovery uses `git ls-files` (tracked files only).
  - With --autocommit, we stage and commit first so new files are tracked.
  - Use --git-include-ignored to force-add ignored files too (careful: secrets).
  - Use --git-init to initialize a repo if none exists.
  - Falls back to walking the directory if Git is unavailable.
"""
from __future__ import annotations

import os
import subprocess
import sys
import time
from pathlib import Path
from typing import Iterable

ROOT = Path.cwd()

DEFAULT_MAX_BYTES = 200_000
DEFAULT_OUTPUT = "repo_dump.txt"

SKIP_NAMES = {".DS_Store", "Thumbs.db"}
SKIP_DIRS = {
    ".git",
    ".hg",
    ".svn",
    ".idea",
    ".vscode",
    ".venv",
    "venv",
    "__pycache__",
    "node_modules",
    "dist",
    "build",
    "staticfiles",
    ".pytest_cache",
    ".mypy_cache",
    ".ruff_cache",
}
SKIP_SUFFIXES = {
    ".pyc",
    ".pyo",
    ".pyd",
    ".so",
    ".dll",
    ".dylib",
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".webp",
    ".svg",
    ".ico",
    ".pdf",
    ".zip",
    ".tar",
    ".gz",
    ".bz2",
    ".xz",
    ".7z",
    ".mp3",
    ".wav",
    ".mp4",
    ".mov",
    ".avi",
    ".sqlite",
    ".sqlite3",
    ".db",
}
SENSITIVE_BASENAMES = {".env", ".env.local", ".envrc", ".secrets", "secrets.json"}


def sh(args, check=True, text=True):
    return subprocess.run(
        args,
        cwd=str(ROOT),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        check=check,
        text=text,
    )


def parse_args(argv):
    out_path = Path(DEFAULT_OUTPUT)
    max_bytes = DEFAULT_MAX_BYTES
    include_sensitive = False
    include_binaries = False
    autocommit = False
    commit_message = None
    git_include_ignored = False
    git_init = False

    i = 0
    if i < len(argv) and not argv[i].startswith("-"):
        out_path = Path(argv[i])
        i += 1
    while i < len(argv):
        a = argv[i]
        if a == "--max-bytes" and i + 1 < len(argv):
            try:
                max_bytes = int(argv[i + 1])
            except ValueError:
                pass
            i += 2
            continue
        if a == "--include-sensitive":
            include_sensitive = True
            i += 1
            continue
        if a == "--include-binaries":
            include_binaries = True
            i += 1
            continue
        if a == "--autocommit":
            autocommit = True
            i += 1
            continue
        if a == "--commit-message" and i + 1 < len(argv):
            commit_message = argv[i + 1]
            i += 2
            continue
        if a == "--git-include-ignored":
            git_include_ignored = True
            i += 1
            continue
        if a == "--git-init":
            git_init = True
            i += 1
            continue
        i += 1

    return (
        out_path,
        max_bytes,
        include_sensitive,
        include_binaries,
        autocommit,
        commit_message,
        git_include_ignored,
        git_init,
    )


def ensure_git_repo(git_init: bool) -> bool:
    try:
        res = sh(["git", "rev-parse", "--is-inside-work-tree"])
        return res.stdout.strip() == "true"
    except Exception:
        if not git_init:
            return False
        try:
            sh(["git", "init"])
            print("[info] initialized new Git repository")
            return True
        except Exception as e:
            print(f"[warn] git init failed: {e}", file=sys.stderr)
            return False


def git_autocommit(commit_message: str | None, include_ignored: bool) -> None:
    """Stage and commit all changes locally. Uses inline identity so it never fails on missing config."""
    if not ensure_git_repo(git_init=False):
        # not a repo; nothing to do
        print("[info] not a Git repo; autocommit skipped")
        return
    try:
        # Stage everything normally
        sh(["git", "add", "-A"])
        # Optionally force-add ignored files too
        if include_ignored:
            # '.' ensures recursion; -f forces ignored files in
            sh(["git", "add", "-f", "."])
            # Also pick up currently-ignored tracked deletions/renames
            try:
                ignored = sh(
                    ["git", "ls-files", "-i", "--exclude-standard"]
                ).stdout.splitlines()
                if ignored:
                    # Best-effort force add; ignore failures
                    sh(["git", "add", "-f"] + ignored, check=False)
            except Exception:
                pass

        # Show staged summary for diagnostics
        staged = sh(
            ["git", "diff", "--cached", "--name-only"], check=False
        ).stdout.strip()
        if not staged:
            print("[info] nothing staged; no commit made")
            return

        if not commit_message:
            ts = time.strftime("%Y-%m-%d %H:%M:%S")
            commit_message = f"auto-commit before export ({ts})"

        # Commit with inline identity so global config is not required
        res = sh(
            [
                "git",
                "-c",
                "user.name=Repo Exporter",
                "-c",
                "user.email=exporter@local",
                "commit",
                "-m",
                commit_message,
            ],
            check=False,
        )
        if res.returncode != 0:
            print(res.stdout)
            print(res.stderr, file=sys.stderr)
            raise RuntimeError("git commit failed")
        print(f"[info] Auto-commit created with {len(staged.splitlines())} path(s).")
    except Exception as e:
        print(f"[warn] autocommit skipped: {e}", file=sys.stderr)


def iter_git_files() -> Iterable[Path]:
    try:
        res = sh(["git", "ls-files"])
        for line in res.stdout.splitlines():
            p = ROOT / line.strip()
            if p.is_file():
                yield p
    except Exception:
        # Fallback if Git not available
        for dirpath, dirnames, filenames in os.walk(ROOT):
            dirnames[:] = [d for d in dirnames if d not in SKIP_DIRS]
            for name in filenames:
                yield Path(dirpath) / name


def looks_binary(path: Path) -> bool:
    try:
        with open(path, "rb") as f:
            chunk = f.read(4096)
        return b"\x00" in chunk
    except Exception:
        return True


def should_skip(path: Path, include_sensitive: bool, include_binaries: bool) -> bool:
    if path.name in SKIP_NAMES:
        return True
    if not include_sensitive and path.name in SENSITIVE_BASENAMES:
        return True
    if any(part in SKIP_DIRS for part in path.parts):
        return True
    if not include_binaries and path.suffix.lower() in SKIP_SUFFIXES:
        return True
    return False


def write_binary_preview(out, path: Path):
    try:
        with open(path, "rb") as f:
            data = f.read(2048)
        out.write("[binary] first 2KB hex preview ({}) bytes:\n".format(len(data)))
        out.write(data.hex() + "\n")
    except Exception:
        out.write("[binary] <unreadable>\n")


def main():
    (
        out_path,
        max_bytes,
        include_sensitive,
        include_binaries,
        autocommit,
        commit_message,
        git_include_ignored,
        git_init,
    ) = parse_args(sys.argv[1:])

    # Optionally initialize a repo
    if git_init and not ensure_git_repo(git_init=True):
        print(
            "[warn] could not initialize Git; continuing without autocommit",
            file=sys.stderr,
        )

    # Commit first if requested
    if autocommit:
        git_autocommit(commit_message, include_ignored=git_include_ignored)

    files = []
    for p in iter_git_files():
        try:
            rel = p.relative_to(ROOT)
        except Exception:
            rel = p
        if should_skip(
            rel, include_sensitive=include_sensitive, include_binaries=include_binaries
        ):
            continue
        try:
            size = (ROOT / rel).stat().st_size
        except Exception:
            continue
        if max_bytes and size > max_bytes:
            continue
        files.append(rel)

    files.sort()

    sep = "=" * 80
    header = [
        "PROJECT EXPORT (plain text)",
        f"Root: {ROOT}",
        f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S %Z')}",
        f"Files included: {len(files)}",
        f"Max bytes per file: {max_bytes if max_bytes else 'no limit'}",
        f"include_sensitive: {include_sensitive}",
        f"include_binaries: {include_binaries}",
        f"autocommit: {autocommit}",
        f"git_include_ignored: {git_include_ignored}",
        "WARNING: If include_sensitive=True, secrets like .env are included in this export.",
        sep,
        "",
    ]
    out_path.write_text("\n".join(header), encoding="utf-8")

    with open(out_path, "a", encoding="utf-8", newline="\n") as out:
        for rel in files:
            abs_path = ROOT / rel
            out.write(f"\n{sep}\nFILE: {rel}\n{sep}\n")
            if include_binaries and looks_binary(abs_path):
                write_binary_preview(out, abs_path)
                continue
            try:
                text = abs_path.read_text(encoding="utf-8", errors="replace")
            except Exception:
                if include_binaries:
                    write_binary_preview(out, abs_path)
                continue
            out.write(text.rstrip("\n") + "\n")

    print(f"Wrote {out_path.resolve()} with {len(files)} files.")


if __name__ == "__main__":
    main()

================================================================================
FILE: exports/assignments.csv
================================================================================
condo_code,unit_number,spot_code,start_date,end_date,is_primary
TSCC1848,1001,P1-002,2025-01-01,,true
TSCC1848,905,P1-001,2025-01-01,,true

================================================================================
FILE: fixtures/sample_data.json
================================================================================
[
  {
    "model": "core.condo",
    "pk": 1,
    "fields": { "code": "TSCC1848", "name": "TSCC 1848" }
  },
  {
    "model": "core.unit",
    "pk": 1,
    "fields": { "condo": 1, "unit_number": "905", "owner_name": "Alex Owner", "owner_email": "alex@example.com", "status": "active" }
  },
  {
    "model": "core.unit",
    "pk": 2,
    "fields": { "condo": 1, "unit_number": "1001", "owner_name": "Blair Owner", "owner_email": "blair@example.com", "status": "active" }
  },
  {
    "model": "core.parkingspot",
    "pk": 1,
    "fields": { "condo": 1, "code": "P1-001", "level": "P1", "spot_type": "owned" }
  },
  {
    "model": "core.parkingspot",
    "pk": 2,
    "fields": { "condo": 1, "code": "P1-002", "level": "P1", "spot_type": "owned" }
  },
  {
    "model": "core.unitparkingassignment",
    "pk": 1,
    "fields": {
      "unit": 1,
      "parking_spot": 1,
      "start_date": "2025-01-01",
      "end_date": null,
      "is_primary": true
    }
  },
  {
    "model": "core.unitparkingassignment",
    "pk": 2,
    "fields": {
      "unit": 2,
      "parking_spot": 2,
      "start_date": "2025-01-01",
      "end_date": null,
      "is_primary": true
    }
  },
  {
    "model": "core.shorttermbooking",
    "pk": 1,
    "fields": {
      "unit": 1,
      "parking_spot": 1,
      "guest_first_name": "Casey",
      "guest_last_name": "Guest",
      "id_type": "DL",
      "id_number": "A1234567",
      "vehicle_plate": "ABCX123",
      "check_in": "2025-09-16T10:00:00Z",
      "check_out": "2025-09-16T14:00:00Z",
      "notes": "fixture booking"
    }
  }
]

================================================================================
FILE: guest_id.txt
================================================================================
fake id bytes

================================================================================
FILE: manage.py
================================================================================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "condo_backend.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()

================================================================================
FILE: requirements.txt
================================================================================
Django==5.2.6
djangorestframework==3.16.1
gunicorn==22.0.0
python-dotenv==1.0.1
django-cors-headers==4.8.0
djangorestframework-simplejwt==5.3.1
django-filter==24.3
flake8
drf-spectacular
drf-spectacular-sidecar
django-crontab==0.7.1

================================================================================
FILE: tests/test_csv_dryrun_and_lookup.py
================================================================================
from django.contrib.auth.models import User
from django.core.files.uploadedfile import SimpleUploadedFile
from django.test import TestCase
from rest_framework.test import APIClient

from core.models import Condo, ParkingSpot, Unit, UnitParkingAssignment


class CsvDryRunAndLookupTests(TestCase):
    fixtures = ["sample_data.json"]

    def setUp(self):
        self.user = User.objects.create_user(username="t", password="t")
        self.client = APIClient()
        self.client.force_authenticate(user=self.user)

    def test_unit_parking_lookup(self):
        unit = Unit.objects.first()
        resp = self.client.get(f"/api/units/{unit.id}/parking")
        self.assertEqual(resp.status_code, 200)
        self.assertIn("results", resp.json())

    def test_spot_unit_lookup(self):
        spot = ParkingSpot.objects.first()
        resp = self.client.get(f"/api/spots/{spot.id}/unit")
        self.assertEqual(resp.status_code, 200)
        self.assertIn("history", resp.json())

    def test_csv_import_dry_run(self):
        condo = Condo.objects.first()
        unit = Unit.objects.filter(condo=condo).first()
        spot = ParkingSpot.objects.filter(condo=condo).first()
        csv_text = (
            "condo_code,unit_number,parking_code,start_date,end_date,is_primary\n"
            f"{condo.code},{unit.unit_number},{spot.code},2025-01-01,,true\n"
        )
        upload = SimpleUploadedFile(
            "dry_run.csv", csv_text.encode("utf-8"), content_type="text/csv"
        )
        resp = self.client.post(
            "/api/assignments/import.csv?dry_run=1",
            {"file": upload},
            format="multipart",
        )
        self.assertEqual(resp.status_code, 200)
        data = resp.json()
        self.assertTrue(data["dry_run"])
        # Ensure DB not changed
        self.assertFalse(
            UnitParkingAssignment.objects.filter(
                unit=unit, parking_spot=spot, is_primary=True
            ).exists()
        )
        self.assertIn("total_rows", data)

================================================================================
FILE: tests/test_lookup_permissions.py
================================================================================
# tests/test_lookup_permissions.py
from django.contrib.auth import get_user_model
from django.test import TestCase
from rest_framework.test import APIClient

from accounts.models import UnitAccess, UserProfile
from core.models import Condo, ParkingSpot, Unit, UnitParkingAssignment


class LookupPermissionsTests(TestCase):
    @classmethod
    def setUpTestData(cls):
        cls.condo = Condo.objects.create(code="CC02", name="Cloud Condo Two")
        cls.unit = Unit.objects.create(condo=cls.condo, unit_number="201")
        cls.spot = ParkingSpot.objects.create(condo=cls.condo, code="B1")
        UnitParkingAssignment.objects.create(
            unit=cls.unit, parking_spot=cls.spot, is_primary=True
        )

        U = get_user_model()
        cls.pm = U.objects.create_user(username="pm2", password="x")
        UserProfile.objects.create(user=cls.pm, role="pm")

        cls.con = U.objects.create_user(username="con2", password="x")
        UserProfile.objects.create(user=cls.con, role="con")

        cls.owner = U.objects.create_user(username="own2", password="x")
        UserProfile.objects.create(user=cls.owner, role="own")
        UnitAccess.objects.create(user=cls.owner, unit=cls.unit)

    def test_unauth_blocked(self):
        c = APIClient()
        self.assertEqual(c.get(f"/api/units/{self.unit.id}/parking").status_code, 401)
        self.assertEqual(c.get(f"/api/spots/{self.spot.id}/unit").status_code, 401)

    def test_pm_allowed(self):
        c = APIClient()
        c.force_authenticate(self.pm)
        self.assertEqual(c.get(f"/api/units/{self.unit.id}/parking").status_code, 200)
        self.assertEqual(c.get(f"/api/spots/{self.spot.id}/unit").status_code, 200)

    def test_concierge_allowed(self):
        c = APIClient()
        c.force_authenticate(self.con)
        self.assertEqual(c.get(f"/api/units/{self.unit.id}/parking").status_code, 200)
        self.assertEqual(c.get(f"/api/spots/{self.spot.id}/unit").status_code, 200)

    def test_owner_allowed(self):
        c = APIClient()
        c.force_authenticate(self.owner)
        self.assertEqual(c.get(f"/api/units/{self.unit.id}/parking").status_code, 200)
        self.assertEqual(c.get(f"/api/spots/{self.spot.id}/unit").status_code, 200)

================================================================================
FILE: tests/test_permissions.py:
================================================================================
# core/tests/test_permissions.py
from django.test import TestCase
from django.contrib.auth import get_user_model
from rest_framework.test import APIClient

from accounts.models import UserProfile, UnitAccess
from core.models import Condo, Unit, ParkingSpot, ShortTermBooking


def mk_user(username, role, is_staff=False, password="pass"):
    U = get_user_model()
    u, created = U.objects.get_or_create(username=username, defaults={"email": f"{username}@example.com"})
    if created:
        u.set_password(password)
        u.is_staff = is_staff
        u.save()
    prof, _ = UserProfile.objects.get_or_create(user=u)
    prof.role = role
    prof.save()
    return u


class PermissionsMatrixTests(TestCase):
    @classmethod
    def setUpTestData(cls):
        # Condo/Unit/Spot
        cls.condo = Condo.objects.create(code="CC01", name="Cloud Condo One", city="Toronto", province="ON")
        cls.unit101 = Unit.objects.create(condo=cls.condo, unit_number="101", owner_name="Owner A", owner_email="owna@example.com", status="active")
        cls.unit102 = Unit.objects.create(condo=cls.condo, unit_number="102", owner_name="Owner B", owner_email="ownb@example.com", status="active")
        cls.spotA1 = ParkingSpot.objects.create(condo=cls.condo, code="A1", level="P1", spot_type="visitor")

        # Users
        cls.pm = mk_user("pm_test", "pm", is_staff=True)
        cls.con = mk_user("con_test", "con", is_staff=True)
        cls.agent = mk_user("agent_test", "agent")
        cls.owner = mk_user("owner_test", "own")

        # Access: agent + owner can act on unit101 only
        UnitAccess.objects.create(user=cls.agent, unit=cls.unit101)
        UnitAccess.objects.create(user=cls.owner, unit=cls.unit101)

    def _auth(self, user=None):
        c = APIClient()
        if user:
            c.force_authenticate(user=user)
        return c

    # ---- Unauthed ----
    def test_unauthed_cannot_list_units(self):
        c = self._auth(None)
        r = c.get("/api/units/")
        self.assertEqual(r.status_code, 401)

    # ---- PM ----
    def test_pm_can_import_export_csv(self):
        c = self._auth(self.pm)
        # export
        r = c.get("/api/assignments/export.csv")
        self.assertEqual(r.status_code, 200)
        self.assertIn("text/csv", r["Content-Type"])

        # import back the same bytes
        from io import BytesIO
        f = BytesIO(r.content)
        f.name = "assignments.csv"
        r2 = c.post("/api/assignments/import.csv", {"file": f}, format="multipart")
        self.assertEqual(r2.status_code, 200)

    # ---- Concierge ----
    def test_concierge_cannot_import_csv(self):
        c = self._auth(self.con)
        r = c.get("/api/assignments/export.csv")
        self.assertEqual(r.status_code, 403)
        # But concierge can list bookings
        r2 = c.get("/api/bookings/")
        # Might be 200 (no data) or 200 with seeded one in other tests
        self.assertEqual(r2.status_code, 200)

    # ---- Agent / Owner booking rules ----
    def test_agent_can_create_booking_only_for_accessible_unit(self):
        c = self._auth(self.agent)
        payload_ok = {
            "unit": self.unit101.id,
            "guest_first_name": "A",
            "guest_last_name": "B",
            "id_type": "passport",
            "id_number": "X1",
            "id_country": "CA",
            "vehicle_plate": "ABC123",
            "parking_spot": self.spotA1.id,
            "check_in": "2025-09-21",
            "check_out": "2025-09-22",
        }
        r1 = c.post("/api/bookings/", payload_ok, format="json")
        self.assertIn(r1.status_code, (201, 200))

        payload_bad = dict(payload_ok, unit=self.unit102.id)
        r2 = c.post("/api/bookings/", payload_bad, format="json")
        self.assertEqual(r2.status_code, 403)

    def test_owner_can_only_see_own_units(self):
        c = self._auth(self.owner)
        r = c.get("/api/units/")
        self.assertEqual(r.status_code, 200)
        nums = [u["unit_number"] for u in r.json()["results"]]
        self.assertIn("101", nums)
        self.assertNotIn("102", nums)


class OpenAPISchemaTests(TestCase):
    def test_schema_endpoint_ok(self):
        c = APIClient()
        # SpectacularAPIView is public by default; if not, auth accordingly
        r = c.get("/api/schema/")
        self.assertEqual(r.status_code, 200)
        self.assertIn("openapi", r.json())

================================================================================
FILE: tests/test_permissions_and_docs.py
================================================================================
import csv
import io

from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APIClient

from accounts.models import UnitAccess, UserProfile
from core.models import Condo, ParkingSpot, Unit, UnitParkingAssignment


class BaseAPITest(TestCase):
    def setUp(self):
        self.client = APIClient()
        U = get_user_model()

        # Users + roles
        self.pm = U.objects.create_user(
            username="pm", password="x", email="pm@example.com", is_staff=True
        )
        UserProfile.objects.create(user=self.pm, role="pm")

        self.con = U.objects.create_user(
            username="con", password="x", email="con@example.com"
        )
        UserProfile.objects.create(user=self.con, role="con")

        self.agent = U.objects.create_user(
            username="agent", password="x", email="agent@example.com"
        )
        UserProfile.objects.create(user=self.agent, role="agent")

        self.owner = U.objects.create_user(
            username="owner", password="x", email="owner@example.com"
        )
        UserProfile.objects.create(user=self.owner, role="own")

        self.rando = U.objects.create_user(
            username="rando", password="x", email="rando@example.com"
        )
        UserProfile.objects.create(user=self.rando, role=None)

        # Data
        self.condo = Condo.objects.create(
            code="C1", name="Condo One", city="Toronto", province="ON"
        )
        self.unit1 = Unit.objects.create(
            condo=self.condo,
            unit_number="101",
            owner_name="Alice",
            owner_email="a@x",
            status="active",
        )
        self.unit2 = Unit.objects.create(
            condo=self.condo,
            unit_number="102",
            owner_name="Bob",
            owner_email="b@x",
            status="active",
        )

        self.spot1 = ParkingSpot.objects.create(
            condo=self.condo, code="S1", level="L1", spot_type="standard"
        )
        self.spot2 = ParkingSpot.objects.create(
            condo=self.condo, code="S2", level="L1", spot_type="standard"
        )

        # Owner + Agent only see unit1
        UnitAccess.objects.create(user=self.owner, unit=self.unit1)
        UnitAccess.objects.create(user=self.agent, unit=self.unit1)

        UnitParkingAssignment.objects.create(
            unit=self.unit1, parking_spot=self.spot1, is_primary=True
        )
        UnitParkingAssignment.objects.create(
            unit=self.unit2, parking_spot=self.spot2, is_primary=True
        )

    # ------- Auth required on core endpoints -------
    def test_units_requires_auth(self):
        resp = self.client.get("/api/units/")
        self.assertEqual(resp.status_code, 401)

    # ------- PM full access; list all units -------
    def test_pm_can_list_all_units(self):
        self.client.force_authenticate(self.pm)
        resp = self.client.get("/api/units/")
        self.assertEqual(resp.status_code, 200)
        # should see both 101 and 102
        nums = [row["unit_number"] for row in resp.data["results"]]
        self.assertCountEqual(nums, ["101", "102"])

    # ------- Owner sees only own units (via UnitAccess) -------
    def test_owner_sees_only_own_units(self):
        self.client.force_authenticate(self.owner)
        resp = self.client.get("/api/units/")
        self.assertEqual(resp.status_code, 200)
        nums = [row["unit_number"] for row in resp.data["results"]]
        self.assertEqual(nums, ["101"])

    # ------- Agent sees only own units (via UnitAccess) -------
    def test_agent_sees_only_own_units(self):
        self.client.force_authenticate(self.agent)
        resp = self.client.get("/api/units/")
        self.assertEqual(resp.status_code, 200)
        nums = [row["unit_number"] for row in resp.data["results"]]
        self.assertEqual(nums, ["101"])

    # ------- Concierge read-only for most models (enforced by view perms) -------
    def test_concierge_list_units_ok(self):
        self.client.force_authenticate(self.con)
        resp = self.client.get("/api/units/")
        self.assertEqual(resp.status_code, 200)

    # ------- CSV export/import: PM only -------
    def test_csv_export_import_permissions(self):
        # export denied for concierge
        self.client.force_authenticate(self.con)
        resp = self.client.get("/api/assignments/export.csv")
        self.assertEqual(resp.status_code, 403)

        # export allowed for PM
        self.client.force_authenticate(self.pm)
        resp = self.client.get("/api/assignments/export.csv")
        self.assertEqual(resp.status_code, 200)
        self.assertIn("text/csv", resp["Content-Type"])

        # import denied for owner/agent/concierge
        for user in [self.owner, self.agent, self.con]:
            self.client.force_authenticate(user)
            resp = self.client.post(
                "/api/assignments/import.csv", data={}, format="multipart"
            )
            self.assertEqual(resp.status_code, 403)

        # import allowed for PM (send a minimal valid CSV from memory)
        self.client.force_authenticate(self.pm)
        mem = io.StringIO()
        w = csv.writer(mem)
        # Header assumed by your service:
        w.writerow(
            [
                "condo_code",
                "unit_number",
                "parking_code",
                "status",
                "effective_start",
                "effective_end",
            ]
        )
        w.writerow(["C1", "101", "S1", "active", "", ""])
        mem.seek(0)

        resp = self.client.post(
            "/api/assignments/import.csv",
            data={"file": io.BytesIO(mem.read().encode("utf-8"))},
            format="multipart",
        )
        self.assertEqual(resp.status_code, 200)
        self.assertIn("created", resp.data)
        self.assertIn("updated", resp.data)
        self.assertIn("errors", resp.data)

    # ------- Docs available anonymously (schema/docs) -------
    def test_openapi_schema_and_docs(self):
        resp = self.client.get("/api/schema/")
        self.assertEqual(resp.status_code, 200)
        resp = self.client.get("/api/docs/")
        self.assertEqual(resp.status_code, 200)
        resp = self.client.get("/api/redoc/")
        self.assertEqual(resp.status_code, 200)

================================================================================
FILE: tests/test_reports.py
================================================================================
# core/tests/test_reports.py
from django.contrib.auth.models import User
from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APIClient

from core.models import Unit


class ReportsTests(TestCase):
    fixtures = ["sample_data.json"]

    def setUp(self):
        self.user = User.objects.create_user(username="t", password="t")
        self.client = APIClient()
        # JWT not required for test; we can force authenticate
        self.client.force_authenticate(user=self.user)

    def test_unit_bookings(self):
        unit = Unit.objects.first()
        resp = self.client.get(f"/api/reports/unit/{unit.id}/bookings")
        self.assertEqual(resp.status_code, 200)
        self.assertIn("results", resp.json())

    def test_available_spots(self):
        resp = self.client.get(
            "/api/reports/available-spots", {"date": "2025-09-16", "condo_id": 1}
        )
        self.assertEqual(resp.status_code, 200)
        self.assertIn("results", resp.json())

    def test_upcoming(self):
        resp = self.client.get("/api/reports/upcoming-checkpoints", {"window": "7d"})
        self.assertEqual(resp.status_code, 200)
        self.assertIn("results", resp.json())

================================================================================
FILE: tests/test_smoke.py
================================================================================
# core/tests/test_smoke.py
from django.test import TestCase
from rest_framework.test import APIClient


class SmokeTests(TestCase):
    def test_healthz(self):
        c = APIClient()
        r = c.get("/api/healthz")
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.json(), {"ok": True})
